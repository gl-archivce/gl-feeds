Index: ot-br-posix-2022-11-08-r3/src/openwrt/ubus/otubus.cpp
===================================================================
--- ot-br-posix-2022-11-08-r3.orig/src/openwrt/ubus/otubus.cpp
+++ ot-br-posix-2022-11-08-r3/src/openwrt/ubus/otubus.cpp
@@ -32,6 +32,16 @@
 
 #define OTBR_LOG_TAG "UBUS"
 
+#define OT_EVENT_OTBR_INIT 0
+#define OT_EVENT_OTBR_ENABLED 1
+#define OT_EVENT_OTBR_DISABLED 2
+#define OT_EVENT_OTBR_NEIGHBOR_TABLE_CHANGED 3
+#define OT_EVENT_OTBR_COMMISSIONER_ENABLED 4
+#define OT_EVENT_OTBR_COMMISSIONER_DISABLED 5
+#define OT_EVENT_OTBR_JOINING_START 6
+#define OT_EVENT_OTBR_JOINING_STOP 7
+#define OT_EVENT_OTBR_WATCHDOG 8
+
 #include "openwrt/ubus/otubus.hpp"
 
 #include <mutex>
@@ -39,19 +49,25 @@
 #include <arpa/inet.h>
 #include <sys/eventfd.h>
 
+#include <openthread/border_router.h>
 #include <openthread/commissioner.h>
+#include <openthread/logging.h>
+#include <openthread/netdata_publisher.h>
+#include <openthread/srp_server.h>
 #include <openthread/thread.h>
 #include <openthread/thread_ftd.h>
 
 #include "common/logging.hpp"
 #include "ncp/ncp_openthread.hpp"
+#include "utils/uci.hpp"
+#include "utils/uci_config.hpp"
 
 namespace otbr {
 namespace ubus {
 
 static UbusServer *sUbusServerInstance = nullptr;
 static int         sUbusEfd            = -1;
-static void *      sJsonUri            = nullptr;
+static void       *sJsonUri            = nullptr;
 static int         sBufNum;
 
 const static int PANID_LENGTH      = 10;
@@ -67,10 +83,12 @@ UbusServer::UbusServer(Ncp::ControllerOp
     , mSecond(0)
 {
     memset(&mNetworkdataBuf, 0, sizeof(mNetworkdataBuf));
+    memset(&mNetworkDiagnosticDataBuf, 0, sizeof(mNetworkDiagnosticDataBuf));
     memset(&mBuf, 0, sizeof(mBuf));
 
     blob_buf_init(&mBuf, 0);
     blob_buf_init(&mNetworkdataBuf, 0);
+    blob_buf_init(&mNetworkDiagnosticDataBuf, 0);
 }
 
 UbusServer &UbusServer::GetInstance(void)
@@ -83,6 +101,44 @@ void UbusServer::Initialize(Ncp::Control
     sUbusServerInstance = new UbusServer(aController, aMutex);
 }
 
+void UbusServer::SendEvent(int aEvent)
+{
+    struct ubus_context   *ctx;
+    const char            *ubus_socket = NULL;
+    static struct blob_buf b;
+    char                   outputKey[NETWORKKEY_LENGTH] = "";
+    otNetworkKey           key;
+    otOperationalDataset   dataset;
+
+    ctx = ubus_connect(ubus_socket);
+    if (!ctx)
+    {
+        otbrLogErr("Ubus connect failed");
+        return;
+    }
+
+    blob_buf_init(&b, 0);
+
+    blobmsg_add_u32(&b, "id", aEvent);
+    if (aEvent != OT_EVENT_OTBR_WATCHDOG)
+    {
+        blobmsg_add_string(&b, "NetworkName", otThreadGetNetworkName(mController->GetInstance()));
+        blobmsg_add_u16(&b, "Channel", otLinkGetChannel(mController->GetInstance()));
+        blobmsg_add_u32(&b, "PanId", otLinkGetPanId(mController->GetInstance()));
+
+        otThreadGetNetworkKey(mController->GetInstance(), &key);
+        OutputBytes(key.m8, OT_NETWORK_KEY_SIZE, outputKey);
+        blobmsg_add_string(&b, "Networkkey", outputKey);
+
+        otDatasetGetActive(mController->GetInstance(), &dataset);
+        blobmsg_add_u64(&b, "ActiveTimestamp", dataset.mActiveTimestamp.mSeconds);
+    }
+
+    ubus_send_event(ctx, "otbr-agent", b.head);
+
+    ubus_free(ctx);
+}
+
 enum
 {
     SETNETWORK,
@@ -93,6 +149,7 @@ enum
 {
     PSKD,
     EUI64,
+    TIMEOUT,
     ADD_JOINER_MAX,
 };
 
@@ -107,6 +164,28 @@ enum
     MGMTSET_MAX,
 };
 
+enum
+{
+    ENABLE,
+    DOMAINNAME,
+    MINLEASE,
+    MAXLEASE,
+    KEYMINLEASE,
+    KEYMAXLEASE,
+    SEQNUM,
+    SET_SRPSRVCONFIG_MAX,
+};
+
+enum
+{
+    BBR_ENABLE,
+    BBR_SEQNO,
+    BBR_DELAY,
+    BBR_TIMEOUT,
+    BBR_JITTER,
+    SET_BBR_CONFIG_MAX,
+};
+
 static const struct blobmsg_policy setNetworknamePolicy[SET_NETWORK_MAX] = {
     [SETNETWORK] = {.name = "networkname", .type = BLOBMSG_TYPE_STRING},
 };
@@ -152,8 +231,9 @@ static const struct blobmsg_policy remov
 };
 
 static const struct blobmsg_policy addJoinerPolicy[ADD_JOINER_MAX] = {
-    [PSKD]  = {.name = "pskd", .type = BLOBMSG_TYPE_STRING},
-    [EUI64] = {.name = "eui64", .type = BLOBMSG_TYPE_STRING},
+    [PSKD]    = {.name = "pskd", .type = BLOBMSG_TYPE_STRING},
+    [EUI64]   = {.name = "eui64", .type = BLOBMSG_TYPE_STRING},
+    [TIMEOUT] = {.name = "timeout", .type = BLOBMSG_TYPE_INT32},
 };
 
 static const struct blobmsg_policy mgmtsetPolicy[MGMTSET_MAX] = {
@@ -165,6 +245,28 @@ static const struct blobmsg_policy mgmts
     [PSKC]        = {.name = "pskc", .type = BLOBMSG_TYPE_STRING},
 };
 
+static const struct blobmsg_policy setLogLevelPolicy[SET_NETWORK_MAX] = {
+    [SETNETWORK] = {.name = "loglevel", .type = BLOBMSG_TYPE_INT32},
+};
+
+static const struct blobmsg_policy setSrpSrvConfigPolicy[SET_SRPSRVCONFIG_MAX] = {
+    [ENABLE]      = {.name = "enable", .type = BLOBMSG_TYPE_BOOL},
+    [DOMAINNAME]  = {.name = "domain", .type = BLOBMSG_TYPE_STRING},
+    [MINLEASE]    = {.name = "minlease", .type = BLOBMSG_TYPE_INT32},
+    [MAXLEASE]    = {.name = "maxlease", .type = BLOBMSG_TYPE_INT32},
+    [KEYMINLEASE] = {.name = "keyminlease", .type = BLOBMSG_TYPE_INT32},
+    [KEYMAXLEASE] = {.name = "keymaxlease", .type = BLOBMSG_TYPE_INT32},
+    [SEQNUM]      = {.name = "seqnum", .type = BLOBMSG_TYPE_INT32},
+};
+
+static const struct blobmsg_policy setBBRConfigPolicy[SET_BBR_CONFIG_MAX] = {
+    [BBR_ENABLE]  = {.name = "enable", .type = BLOBMSG_TYPE_BOOL},
+    [BBR_SEQNO]   = {.name = "seqno", .type = BLOBMSG_TYPE_INT32},
+    [BBR_DELAY]   = {.name = "delay", .type = BLOBMSG_TYPE_INT32},
+    [BBR_TIMEOUT] = {.name = "timeout", .type = BLOBMSG_TYPE_INT32},
+    [BBR_JITTER]  = {.name = "jitter", .type = BLOBMSG_TYPE_INT32},
+};
+
 static const struct ubus_method otbrMethods[] = {
     {"scan", &UbusServer::UbusScanHandler, 0, 0, nullptr, 0},
     {"channel", &UbusServer::UbusChannelHandler, 0, 0, nullptr, 0},
@@ -195,7 +297,7 @@ static const struct ubus_method otbrMeth
     {"networkdata", &UbusServer::UbusNetworkdataHandler, 0, 0, nullptr, 0},
     {"commissionerstart", &UbusServer::UbusCommissionerStartHandler, 0, 0, nullptr, 0},
     {"joinernum", &UbusServer::UbusJoinerNumHandler, 0, 0, nullptr, 0},
-    {"joinerremove", &UbusServer::UbusJoinerRemoveHandler, 0, 0, nullptr, 0},
+    {"joinerremove", &UbusServer::UbusJoinerRemoveHandler, 0, 0, removeJoinerPolicy, ARRAY_SIZE(removeJoinerPolicy)},
     {"macfiltersetstate", &UbusServer::UbusMacfilterSetStateHandler, 0, 0, macfilterSetStatePolicy,
      ARRAY_SIZE(macfilterSetStatePolicy)},
     {"macfilteradd", &UbusServer::UbusMacfilterAddHandler, 0, 0, macfilterAddPolicy, ARRAY_SIZE(macfilterAddPolicy)},
@@ -206,6 +308,25 @@ static const struct ubus_method otbrMeth
     {"macfilteraddr", &UbusServer::UbusMacfilterAddrHandler, 0, 0, nullptr, 0},
     {"joineradd", &UbusServer::UbusJoinerAddHandler, 0, 0, addJoinerPolicy, ARRAY_SIZE(addJoinerPolicy)},
     {"mgmtset", &UbusServer::UbusMgmtsetHandler, 0, 0, mgmtsetPolicy, ARRAY_SIZE(mgmtsetPolicy)},
+    {"status", &UbusServer::UbusExtGetThreadStatus, 0, 0, nullptr, 0},
+    {"networkdiagnostic", &UbusServer::UbusExtGetThreadGraph, 0, 0, nullptr, 0},
+    {"txpower", &UbusServer::UbusExtGetTxPower, 0, 0, nullptr, 0},
+    {"thread_join_state", &UbusServer::UbusExtJoinerState, 0, 0, nullptr, 0},
+    {"commissionerstop", &UbusServer::UbusExtCommissionerStopHandler, 0, 0, nullptr, 0},
+    {"commissionerstate", &UbusServer::UbusExtCommissionerStateHandler, 0, 0, nullptr, 0},
+#if OTBR_ENABLE_BACKBONE_ROUTER
+    {"bbrstatus", &UbusServer::UbusGetBBRStatus, 0, 0, nullptr, 0},
+    {"bbrconfig", &UbusServer::UbusSetBBRConfigHandler, 0, 0, setBBRConfigPolicy, ARRAY_SIZE(setBBRConfigPolicy)},
+#endif
+    {"setloglevel", &UbusServer::UbusSetLogLevelHandler, 0, 0, setLogLevelPolicy, ARRAY_SIZE(setLogLevelPolicy)},
+    {"srpsrvconfig", &UbusServer::UbusGetSrpServerConfigHandler, 0, 0, nullptr, 0},
+    {"srpsrvservice", &UbusServer::UbusGetSrpServerServiceHandler, 0, 0, nullptr, 0},
+    {"setsrpsrvconfig", &UbusServer::UbusSetSrpServerConfigHandler, 0, 0, setSrpSrvConfigPolicy,
+     ARRAY_SIZE(setSrpSrvConfigPolicy)},
+    {"localaddr", &UbusServer::UbusGetLocalAddrHandler, 0, 0, nullptr, 0},
+    {"activetimestamp", &UbusServer::UbusGetActiveTimestampHandler, 0, 0, nullptr, 0},
+    {"bufferinfo", &UbusServer::UbusGetBufferInfoHandler, 0, 0, nullptr, 0},
+    {"services", &UbusServer::UbusGetServicesInfoHandler, 0, 0, nullptr, 0},
 };
 
 static struct ubus_object_type otbrObjType = {"otbr_prog", 0, otbrMethods, ARRAY_SIZE(otbrMethods)};
@@ -293,20 +414,20 @@ exit:
     return;
 }
 
-int UbusServer::UbusScanHandler(struct ubus_context *     aContext,
-                                struct ubus_object *      aObj,
+int UbusServer::UbusScanHandler(struct ubus_context      *aContext,
+                                struct ubus_object       *aObj,
                                 struct ubus_request_data *aRequest,
-                                const char *              aMethod,
-                                struct blob_attr *        aMsg)
+                                const char               *aMethod,
+                                struct blob_attr         *aMsg)
 {
     return GetInstance().UbusScanHandlerDetail(aContext, aObj, aRequest, aMethod, aMsg);
 }
 
-int UbusServer::UbusScanHandlerDetail(struct ubus_context *     aContext,
-                                      struct ubus_object *      aObj,
+int UbusServer::UbusScanHandlerDetail(struct ubus_context      *aContext,
+                                      struct ubus_object       *aObj,
                                       struct ubus_request_data *aRequest,
-                                      const char *              aMethod,
-                                      struct blob_attr *        aMsg)
+                                      const char               *aMethod,
+                                      struct blob_attr         *aMsg)
 {
     OT_UNUSED_VARIABLE(aObj);
     OT_UNUSED_VARIABLE(aMethod);
@@ -340,326 +461,472 @@ exit:
     return 0;
 }
 
-int UbusServer::UbusChannelHandler(struct ubus_context *     aContext,
-                                   struct ubus_object *      aObj,
+int UbusServer::UbusChannelHandler(struct ubus_context      *aContext,
+                                   struct ubus_object       *aObj,
                                    struct ubus_request_data *aRequest,
-                                   const char *              aMethod,
-                                   struct blob_attr *        aMsg)
+                                   const char               *aMethod,
+                                   struct blob_attr         *aMsg)
 {
     return GetInstance().UbusGetInformation(aContext, aObj, aRequest, aMethod, aMsg, "channel");
 }
 
-int UbusServer::UbusSetChannelHandler(struct ubus_context *     aContext,
-                                      struct ubus_object *      aObj,
+int UbusServer::UbusSetChannelHandler(struct ubus_context      *aContext,
+                                      struct ubus_object       *aObj,
                                       struct ubus_request_data *aRequest,
-                                      const char *              aMethod,
-                                      struct blob_attr *        aMsg)
+                                      const char               *aMethod,
+                                      struct blob_attr         *aMsg)
 {
     return GetInstance().UbusSetInformation(aContext, aObj, aRequest, aMethod, aMsg, "channel");
 }
 
-int UbusServer::UbusJoinerNumHandler(struct ubus_context *     aContext,
-                                     struct ubus_object *      aObj,
+int UbusServer::UbusJoinerNumHandler(struct ubus_context      *aContext,
+                                     struct ubus_object       *aObj,
                                      struct ubus_request_data *aRequest,
-                                     const char *              aMethod,
-                                     struct blob_attr *        aMsg)
+                                     const char               *aMethod,
+                                     struct blob_attr         *aMsg)
 {
     return GetInstance().UbusGetInformation(aContext, aObj, aRequest, aMethod, aMsg, "joinernum");
 }
 
-int UbusServer::UbusNetworknameHandler(struct ubus_context *     aContext,
-                                       struct ubus_object *      aObj,
+int UbusServer::UbusNetworknameHandler(struct ubus_context      *aContext,
+                                       struct ubus_object       *aObj,
                                        struct ubus_request_data *aRequest,
-                                       const char *              aMethod,
-                                       struct blob_attr *        aMsg)
+                                       const char               *aMethod,
+                                       struct blob_attr         *aMsg)
 {
     return GetInstance().UbusGetInformation(aContext, aObj, aRequest, aMethod, aMsg, "networkname");
 }
 
-int UbusServer::UbusSetNetworknameHandler(struct ubus_context *     aContext,
-                                          struct ubus_object *      aObj,
+int UbusServer::UbusSetNetworknameHandler(struct ubus_context      *aContext,
+                                          struct ubus_object       *aObj,
                                           struct ubus_request_data *aRequest,
-                                          const char *              aMethod,
-                                          struct blob_attr *        aMsg)
+                                          const char               *aMethod,
+                                          struct blob_attr         *aMsg)
 {
     return GetInstance().UbusSetInformation(aContext, aObj, aRequest, aMethod, aMsg, "networkname");
 }
 
-int UbusServer::UbusStateHandler(struct ubus_context *     aContext,
-                                 struct ubus_object *      aObj,
+int UbusServer::UbusStateHandler(struct ubus_context      *aContext,
+                                 struct ubus_object       *aObj,
                                  struct ubus_request_data *aRequest,
-                                 const char *              aMethod,
-                                 struct blob_attr *        aMsg)
+                                 const char               *aMethod,
+                                 struct blob_attr         *aMsg)
 {
     return GetInstance().UbusGetInformation(aContext, aObj, aRequest, aMethod, aMsg, "state");
 }
 
-int UbusServer::UbusRloc16Handler(struct ubus_context *     aContext,
-                                  struct ubus_object *      aObj,
+int UbusServer::UbusRloc16Handler(struct ubus_context      *aContext,
+                                  struct ubus_object       *aObj,
                                   struct ubus_request_data *aRequest,
-                                  const char *              aMethod,
-                                  struct blob_attr *        aMsg)
+                                  const char               *aMethod,
+                                  struct blob_attr         *aMsg)
 {
     return GetInstance().UbusGetInformation(aContext, aObj, aRequest, aMethod, aMsg, "rloc16");
 }
 
-int UbusServer::UbusPanIdHandler(struct ubus_context *     aContext,
-                                 struct ubus_object *      aObj,
+int UbusServer::UbusPanIdHandler(struct ubus_context      *aContext,
+                                 struct ubus_object       *aObj,
                                  struct ubus_request_data *aRequest,
-                                 const char *              aMethod,
-                                 struct blob_attr *        aMsg)
+                                 const char               *aMethod,
+                                 struct blob_attr         *aMsg)
 {
     return GetInstance().UbusGetInformation(aContext, aObj, aRequest, aMethod, aMsg, "panid");
 }
 
-int UbusServer::UbusSetPanIdHandler(struct ubus_context *     aContext,
-                                    struct ubus_object *      aObj,
+int UbusServer::UbusSetPanIdHandler(struct ubus_context      *aContext,
+                                    struct ubus_object       *aObj,
                                     struct ubus_request_data *aRequest,
-                                    const char *              aMethod,
-                                    struct blob_attr *        aMsg)
+                                    const char               *aMethod,
+                                    struct blob_attr         *aMsg)
 {
     return GetInstance().UbusSetInformation(aContext, aObj, aRequest, aMethod, aMsg, "panid");
 }
 
-int UbusServer::UbusExtPanIdHandler(struct ubus_context *     aContext,
-                                    struct ubus_object *      aObj,
+int UbusServer::UbusExtPanIdHandler(struct ubus_context      *aContext,
+                                    struct ubus_object       *aObj,
                                     struct ubus_request_data *aRequest,
-                                    const char *              aMethod,
-                                    struct blob_attr *        aMsg)
+                                    const char               *aMethod,
+                                    struct blob_attr         *aMsg)
 {
     return GetInstance().UbusGetInformation(aContext, aObj, aRequest, aMethod, aMsg, "extpanid");
 }
 
-int UbusServer::UbusSetExtPanIdHandler(struct ubus_context *     aContext,
-                                       struct ubus_object *      aObj,
+int UbusServer::UbusSetExtPanIdHandler(struct ubus_context      *aContext,
+                                       struct ubus_object       *aObj,
                                        struct ubus_request_data *aRequest,
-                                       const char *              aMethod,
-                                       struct blob_attr *        aMsg)
+                                       const char               *aMethod,
+                                       struct blob_attr         *aMsg)
 {
     return GetInstance().UbusSetInformation(aContext, aObj, aRequest, aMethod, aMsg, "extpanid");
 }
 
-int UbusServer::UbusPskcHandler(struct ubus_context *     aContext,
-                                struct ubus_object *      aObj,
+int UbusServer::UbusPskcHandler(struct ubus_context      *aContext,
+                                struct ubus_object       *aObj,
                                 struct ubus_request_data *aRequest,
-                                const char *              aMethod,
-                                struct blob_attr *        aMsg)
+                                const char               *aMethod,
+                                struct blob_attr         *aMsg)
 {
     return GetInstance().UbusGetInformation(aContext, aObj, aRequest, aMethod, aMsg, "pskc");
 }
 
-int UbusServer::UbusSetPskcHandler(struct ubus_context *     aContext,
-                                   struct ubus_object *      aObj,
+int UbusServer::UbusSetPskcHandler(struct ubus_context      *aContext,
+                                   struct ubus_object       *aObj,
                                    struct ubus_request_data *aRequest,
-                                   const char *              aMethod,
-                                   struct blob_attr *        aMsg)
+                                   const char               *aMethod,
+                                   struct blob_attr         *aMsg)
 {
     return GetInstance().UbusSetInformation(aContext, aObj, aRequest, aMethod, aMsg, "pskc");
 }
 
-int UbusServer::UbusNetworkkeyHandler(struct ubus_context *     aContext,
-                                      struct ubus_object *      aObj,
+int UbusServer::UbusNetworkkeyHandler(struct ubus_context      *aContext,
+                                      struct ubus_object       *aObj,
                                       struct ubus_request_data *aRequest,
-                                      const char *              aMethod,
-                                      struct blob_attr *        aMsg)
+                                      const char               *aMethod,
+                                      struct blob_attr         *aMsg)
 {
     return GetInstance().UbusGetInformation(aContext, aObj, aRequest, aMethod, aMsg, "networkkey");
 }
 
-int UbusServer::UbusSetNetworkkeyHandler(struct ubus_context *     aContext,
-                                         struct ubus_object *      aObj,
+int UbusServer::UbusSetNetworkkeyHandler(struct ubus_context      *aContext,
+                                         struct ubus_object       *aObj,
                                          struct ubus_request_data *aRequest,
-                                         const char *              aMethod,
-                                         struct blob_attr *        aMsg)
+                                         const char               *aMethod,
+                                         struct blob_attr         *aMsg)
 {
     return GetInstance().UbusSetInformation(aContext, aObj, aRequest, aMethod, aMsg, "networkkey");
 }
 
-int UbusServer::UbusThreadStartHandler(struct ubus_context *     aContext,
-                                       struct ubus_object *      aObj,
+int UbusServer::UbusThreadStartHandler(struct ubus_context      *aContext,
+                                       struct ubus_object       *aObj,
                                        struct ubus_request_data *aRequest,
-                                       const char *              aMethod,
-                                       struct blob_attr *        aMsg)
+                                       const char               *aMethod,
+                                       struct blob_attr         *aMsg)
 {
     return GetInstance().UbusThreadHandler(aContext, aObj, aRequest, aMethod, aMsg, "start");
 }
 
-int UbusServer::UbusThreadStopHandler(struct ubus_context *     aContext,
-                                      struct ubus_object *      aObj,
+int UbusServer::UbusThreadStopHandler(struct ubus_context      *aContext,
+                                      struct ubus_object       *aObj,
                                       struct ubus_request_data *aRequest,
-                                      const char *              aMethod,
-                                      struct blob_attr *        aMsg)
+                                      const char               *aMethod,
+                                      struct blob_attr         *aMsg)
 {
     return GetInstance().UbusThreadHandler(aContext, aObj, aRequest, aMethod, aMsg, "stop");
 }
 
-int UbusServer::UbusParentHandler(struct ubus_context *     aContext,
-                                  struct ubus_object *      aObj,
+int UbusServer::UbusParentHandler(struct ubus_context      *aContext,
+                                  struct ubus_object       *aObj,
                                   struct ubus_request_data *aRequest,
-                                  const char *              aMethod,
-                                  struct blob_attr *        aMsg)
+                                  const char               *aMethod,
+                                  struct blob_attr         *aMsg)
 {
     return GetInstance().UbusParentHandlerDetail(aContext, aObj, aRequest, aMethod, aMsg);
 }
 
-int UbusServer::UbusNeighborHandler(struct ubus_context *     aContext,
-                                    struct ubus_object *      aObj,
+int UbusServer::UbusNeighborHandler(struct ubus_context      *aContext,
+                                    struct ubus_object       *aObj,
                                     struct ubus_request_data *aRequest,
-                                    const char *              aMethod,
-                                    struct blob_attr *        aMsg)
+                                    const char               *aMethod,
+                                    struct blob_attr         *aMsg)
 {
     return GetInstance().UbusNeighborHandlerDetail(aContext, aObj, aRequest, aMethod, aMsg);
 }
 
-int UbusServer::UbusModeHandler(struct ubus_context *     aContext,
-                                struct ubus_object *      aObj,
+int UbusServer::UbusModeHandler(struct ubus_context      *aContext,
+                                struct ubus_object       *aObj,
                                 struct ubus_request_data *aRequest,
-                                const char *              aMethod,
-                                struct blob_attr *        aMsg)
+                                const char               *aMethod,
+                                struct blob_attr         *aMsg)
 {
     return GetInstance().UbusGetInformation(aContext, aObj, aRequest, aMethod, aMsg, "mode");
 }
 
-int UbusServer::UbusSetModeHandler(struct ubus_context *     aContext,
-                                   struct ubus_object *      aObj,
+int UbusServer::UbusSetModeHandler(struct ubus_context      *aContext,
+                                   struct ubus_object       *aObj,
                                    struct ubus_request_data *aRequest,
-                                   const char *              aMethod,
-                                   struct blob_attr *        aMsg)
+                                   const char               *aMethod,
+                                   struct blob_attr         *aMsg)
 {
     return GetInstance().UbusSetInformation(aContext, aObj, aRequest, aMethod, aMsg, "mode");
 }
 
-int UbusServer::UbusPartitionIdHandler(struct ubus_context *     aContext,
-                                       struct ubus_object *      aObj,
+int UbusServer::UbusPartitionIdHandler(struct ubus_context      *aContext,
+                                       struct ubus_object       *aObj,
                                        struct ubus_request_data *aRequest,
-                                       const char *              aMethod,
-                                       struct blob_attr *        aMsg)
+                                       const char               *aMethod,
+                                       struct blob_attr         *aMsg)
 {
     return GetInstance().UbusGetInformation(aContext, aObj, aRequest, aMethod, aMsg, "partitionid");
 }
 
-int UbusServer::UbusLeaveHandler(struct ubus_context *     aContext,
-                                 struct ubus_object *      aObj,
+int UbusServer::UbusLeaveHandler(struct ubus_context      *aContext,
+                                 struct ubus_object       *aObj,
                                  struct ubus_request_data *aRequest,
-                                 const char *              aMethod,
-                                 struct blob_attr *        aMsg)
+                                 const char               *aMethod,
+                                 struct blob_attr         *aMsg)
 {
     return GetInstance().UbusLeaveHandlerDetail(aContext, aObj, aRequest, aMethod, aMsg);
 }
 
-int UbusServer::UbusLeaderdataHandler(struct ubus_context *     aContext,
-                                      struct ubus_object *      aObj,
+int UbusServer::UbusLeaderdataHandler(struct ubus_context      *aContext,
+                                      struct ubus_object       *aObj,
                                       struct ubus_request_data *aRequest,
-                                      const char *              aMethod,
-                                      struct blob_attr *        aMsg)
+                                      const char               *aMethod,
+                                      struct blob_attr         *aMsg)
 {
     return GetInstance().UbusGetInformation(aContext, aObj, aRequest, aMethod, aMsg, "leaderdata");
 }
 
-int UbusServer::UbusNetworkdataHandler(struct ubus_context *     aContext,
-                                       struct ubus_object *      aObj,
+int UbusServer::UbusNetworkdataHandler(struct ubus_context      *aContext,
+                                       struct ubus_object       *aObj,
                                        struct ubus_request_data *aRequest,
-                                       const char *              aMethod,
-                                       struct blob_attr *        aMsg)
+                                       const char               *aMethod,
+                                       struct blob_attr         *aMsg)
 {
     return GetInstance().UbusGetInformation(aContext, aObj, aRequest, aMethod, aMsg, "networkdata");
 }
 
-int UbusServer::UbusCommissionerStartHandler(struct ubus_context *     aContext,
-                                             struct ubus_object *      aObj,
+int UbusServer::UbusCommissionerStartHandler(struct ubus_context      *aContext,
+                                             struct ubus_object       *aObj,
                                              struct ubus_request_data *aRequest,
-                                             const char *              aMethod,
-                                             struct blob_attr *        aMsg)
+                                             const char               *aMethod,
+                                             struct blob_attr         *aMsg)
 {
     return GetInstance().UbusCommissioner(aContext, aObj, aRequest, aMethod, aMsg, "start");
 }
 
-int UbusServer::UbusJoinerRemoveHandler(struct ubus_context *     aContext,
-                                        struct ubus_object *      aObj,
+int UbusServer::UbusJoinerRemoveHandler(struct ubus_context      *aContext,
+                                        struct ubus_object       *aObj,
                                         struct ubus_request_data *aRequest,
-                                        const char *              aMethod,
-                                        struct blob_attr *        aMsg)
+                                        const char               *aMethod,
+                                        struct blob_attr         *aMsg)
 {
     return GetInstance().UbusCommissioner(aContext, aObj, aRequest, aMethod, aMsg, "joinerremove");
 }
 
-int UbusServer::UbusMgmtsetHandler(struct ubus_context *     aContext,
-                                   struct ubus_object *      aObj,
+int UbusServer::UbusMgmtsetHandler(struct ubus_context      *aContext,
+                                   struct ubus_object       *aObj,
                                    struct ubus_request_data *aRequest,
-                                   const char *              aMethod,
-                                   struct blob_attr *        aMsg)
+                                   const char               *aMethod,
+                                   struct blob_attr         *aMsg)
 {
     return GetInstance().UbusMgmtset(aContext, aObj, aRequest, aMethod, aMsg);
 }
 
-int UbusServer::UbusJoinerAddHandler(struct ubus_context *     aContext,
-                                     struct ubus_object *      aObj,
+int UbusServer::UbusJoinerAddHandler(struct ubus_context      *aContext,
+                                     struct ubus_object       *aObj,
                                      struct ubus_request_data *aRequest,
-                                     const char *              aMethod,
-                                     struct blob_attr *        aMsg)
+                                     const char               *aMethod,
+                                     struct blob_attr         *aMsg)
 {
     return GetInstance().UbusCommissioner(aContext, aObj, aRequest, aMethod, aMsg, "joineradd");
 }
 
-int UbusServer::UbusMacfilterAddrHandler(struct ubus_context *     aContext,
-                                         struct ubus_object *      aObj,
+int UbusServer::UbusMacfilterAddrHandler(struct ubus_context      *aContext,
+                                         struct ubus_object       *aObj,
                                          struct ubus_request_data *aRequest,
-                                         const char *              aMethod,
-                                         struct blob_attr *        aMsg)
+                                         const char               *aMethod,
+                                         struct blob_attr         *aMsg)
 {
     return GetInstance().UbusGetInformation(aContext, aObj, aRequest, aMethod, aMsg, "macfilteraddr");
 }
 
-int UbusServer::UbusMacfilterStateHandler(struct ubus_context *     aContext,
-                                          struct ubus_object *      aObj,
+int UbusServer::UbusMacfilterStateHandler(struct ubus_context      *aContext,
+                                          struct ubus_object       *aObj,
                                           struct ubus_request_data *aRequest,
-                                          const char *              aMethod,
-                                          struct blob_attr *        aMsg)
+                                          const char               *aMethod,
+                                          struct blob_attr         *aMsg)
 {
     return GetInstance().UbusGetInformation(aContext, aObj, aRequest, aMethod, aMsg, "macfilterstate");
 }
 
-int UbusServer::UbusMacfilterAddHandler(struct ubus_context *     aContext,
-                                        struct ubus_object *      aObj,
+int UbusServer::UbusMacfilterAddHandler(struct ubus_context      *aContext,
+                                        struct ubus_object       *aObj,
                                         struct ubus_request_data *aRequest,
-                                        const char *              aMethod,
-                                        struct blob_attr *        aMsg)
+                                        const char               *aMethod,
+                                        struct blob_attr         *aMsg)
 {
     return GetInstance().UbusSetInformation(aContext, aObj, aRequest, aMethod, aMsg, "macfilteradd");
 }
 
-int UbusServer::UbusMacfilterRemoveHandler(struct ubus_context *     aContext,
-                                           struct ubus_object *      aObj,
+int UbusServer::UbusMacfilterRemoveHandler(struct ubus_context      *aContext,
+                                           struct ubus_object       *aObj,
                                            struct ubus_request_data *aRequest,
-                                           const char *              aMethod,
-                                           struct blob_attr *        aMsg)
+                                           const char               *aMethod,
+                                           struct blob_attr         *aMsg)
 {
     return GetInstance().UbusSetInformation(aContext, aObj, aRequest, aMethod, aMsg, "macfilterremove");
 }
 
-int UbusServer::UbusMacfilterSetStateHandler(struct ubus_context *     aContext,
-                                             struct ubus_object *      aObj,
+int UbusServer::UbusMacfilterSetStateHandler(struct ubus_context      *aContext,
+                                             struct ubus_object       *aObj,
                                              struct ubus_request_data *aRequest,
-                                             const char *              aMethod,
-                                             struct blob_attr *        aMsg)
+                                             const char               *aMethod,
+                                             struct blob_attr         *aMsg)
 {
     return GetInstance().UbusSetInformation(aContext, aObj, aRequest, aMethod, aMsg, "macfiltersetstate");
 }
 
-int UbusServer::UbusMacfilterClearHandler(struct ubus_context *     aContext,
-                                          struct ubus_object *      aObj,
+int UbusServer::UbusMacfilterClearHandler(struct ubus_context      *aContext,
+                                          struct ubus_object       *aObj,
                                           struct ubus_request_data *aRequest,
-                                          const char *              aMethod,
-                                          struct blob_attr *        aMsg)
+                                          const char               *aMethod,
+                                          struct blob_attr         *aMsg)
 {
     return GetInstance().UbusSetInformation(aContext, aObj, aRequest, aMethod, aMsg, "macfilterclear");
 }
 
-int UbusServer::UbusLeaveHandlerDetail(struct ubus_context *     aContext,
-                                       struct ubus_object *      aObj,
+int UbusServer::UbusExtGetThreadStatus(struct ubus_context      *aContext,
+                                       struct ubus_object       *aObj,
                                        struct ubus_request_data *aRequest,
-                                       const char *              aMethod,
-                                       struct blob_attr *        aMsg)
+                                       const char               *aMethod,
+                                       struct blob_attr         *aMsg)
+{
+    return GetInstance().UbusGetInformation(aContext, aObj, aRequest, aMethod, aMsg, "status");
+}
+
+int UbusServer::UbusExtGetThreadGraph(struct ubus_context      *aContext,
+                                      struct ubus_object       *aObj,
+                                      struct ubus_request_data *aRequest,
+                                      const char               *aMethod,
+                                      struct blob_attr         *aMsg)
+{
+    return GetInstance().UbusGetInformation(aContext, aObj, aRequest, aMethod, aMsg, "networkdiagnostic");
+}
+
+int UbusServer::UbusExtGetTxPower(struct ubus_context      *aContext,
+                                  struct ubus_object       *aObj,
+                                  struct ubus_request_data *aRequest,
+                                  const char               *aMethod,
+                                  struct blob_attr         *aMsg)
+{
+    return GetInstance().UbusGetInformation(aContext, aObj, aRequest, aMethod, aMsg, "txpower");
+}
+
+int UbusServer::UbusExtJoinerState(struct ubus_context      *aContext,
+                                   struct ubus_object       *aObj,
+                                   struct ubus_request_data *aRequest,
+                                   const char               *aMethod,
+                                   struct blob_attr         *aMsg)
+{
+    return GetInstance().UbusGetInformation(aContext, aObj, aRequest, aMethod, aMsg, "thread_join_state");
+}
+
+int UbusServer::UbusExtCommissionerStopHandler(struct ubus_context      *aContext,
+                                               struct ubus_object       *aObj,
+                                               struct ubus_request_data *aRequest,
+                                               const char               *aMethod,
+                                               struct blob_attr         *aMsg)
+{
+    return GetInstance().UbusCommissioner(aContext, aObj, aRequest, aMethod, aMsg, "stop");
+}
+
+int UbusServer::UbusExtCommissionerStateHandler(struct ubus_context      *aContext,
+                                                struct ubus_object       *aObj,
+                                                struct ubus_request_data *aRequest,
+                                                const char               *aMethod,
+                                                struct blob_attr         *aMsg)
+{
+    return GetInstance().UbusCommissioner(aContext, aObj, aRequest, aMethod, aMsg, "state");
+}
+
+#if OTBR_ENABLE_BACKBONE_ROUTER
+int UbusServer::UbusGetBBRStatus(struct ubus_context      *aContext,
+                                 struct ubus_object       *aObj,
+                                 struct ubus_request_data *aRequest,
+                                 const char               *aMethod,
+                                 struct blob_attr         *aMsg)
+{
+    return GetInstance().UbusGetInformation(aContext, aObj, aRequest, aMethod, aMsg, "bbrstatus");
+}
+
+int UbusServer::UbusSetBBRConfigHandler(struct ubus_context      *aContext,
+                                        struct ubus_object       *aObj,
+                                        struct ubus_request_data *aRequest,
+                                        const char               *aMethod,
+                                        struct blob_attr         *aMsg)
+{
+    return GetInstance().UbusSetInformation(aContext, aObj, aRequest, aMethod, aMsg, "setbbrconfig");
+}
+#endif
+
+int UbusServer::UbusGetSrpServerConfigHandler(struct ubus_context      *aContext,
+                                              struct ubus_object       *aObj,
+                                              struct ubus_request_data *aRequest,
+                                              const char               *aMethod,
+                                              struct blob_attr         *aMsg)
+{
+    return GetInstance().UbusGetInformation(aContext, aObj, aRequest, aMethod, aMsg, "srpsrvconfig");
+}
+
+int UbusServer::UbusGetSrpServerServiceHandler(struct ubus_context      *aContext,
+                                               struct ubus_object       *aObj,
+                                               struct ubus_request_data *aRequest,
+                                               const char               *aMethod,
+                                               struct blob_attr         *aMsg)
+{
+    return GetInstance().UbusGetInformation(aContext, aObj, aRequest, aMethod, aMsg, "srpsrvservice");
+}
+
+int UbusServer::UbusSetSrpServerConfigHandler(struct ubus_context      *aContext,
+                                              struct ubus_object       *aObj,
+                                              struct ubus_request_data *aRequest,
+                                              const char               *aMethod,
+                                              struct blob_attr         *aMsg)
+{
+    return GetInstance().UbusSetInformation(aContext, aObj, aRequest, aMethod, aMsg, "setsrpsrvconfig");
+}
+
+int UbusServer::UbusGetLocalAddrHandler(struct ubus_context      *aContext,
+                                        struct ubus_object       *aObj,
+                                        struct ubus_request_data *aRequest,
+                                        const char               *aMethod,
+                                        struct blob_attr         *aMsg)
+{
+    return GetInstance().UbusGetInformation(aContext, aObj, aRequest, aMethod, aMsg, "localaddr");
+}
+
+int UbusServer::UbusGetActiveTimestampHandler(struct ubus_context      *aContext,
+                                              struct ubus_object       *aObj,
+                                              struct ubus_request_data *aRequest,
+                                              const char               *aMethod,
+                                              struct blob_attr         *aMsg)
+{
+    return GetInstance().UbusGetInformation(aContext, aObj, aRequest, aMethod, aMsg, "activetimestamp");
+}
+
+int UbusServer::UbusGetBufferInfoHandler(struct ubus_context      *aContext,
+                                         struct ubus_object       *aObj,
+                                         struct ubus_request_data *aRequest,
+                                         const char               *aMethod,
+                                         struct blob_attr         *aMsg)
+{
+    return GetInstance().UbusGetInformation(aContext, aObj, aRequest, aMethod, aMsg, "bufferinfo");
+}
+
+int UbusServer::UbusGetServicesInfoHandler(struct ubus_context      *aContext,
+                                           struct ubus_object       *aObj,
+                                           struct ubus_request_data *aRequest,
+                                           const char               *aMethod,
+                                           struct blob_attr         *aMsg)
+{
+    return GetInstance().UbusGetInformation(aContext, aObj, aRequest, aMethod, aMsg, "services");
+}
+
+int UbusServer::UbusSetLogLevelHandler(struct ubus_context      *aContext,
+                                       struct ubus_object       *aObj,
+                                       struct ubus_request_data *aRequest,
+                                       const char               *aMethod,
+                                       struct blob_attr         *aMsg)
+{
+    return GetInstance().UbusSetInformation(aContext, aObj, aRequest, aMethod, aMsg, "loglevel");
+}
+
+int UbusServer::UbusLeaveHandlerDetail(struct ubus_context      *aContext,
+                                       struct ubus_object       *aObj,
+                                       struct ubus_request_data *aRequest,
+                                       const char               *aMethod,
+                                       struct blob_attr         *aMsg)
 {
     OT_UNUSED_VARIABLE(aObj);
     OT_UNUSED_VARIABLE(aMethod);
@@ -687,12 +954,12 @@ exit:
     AppendResult(error, aContext, aRequest);
     return 0;
 }
-int UbusServer::UbusThreadHandler(struct ubus_context *     aContext,
-                                  struct ubus_object *      aObj,
+int UbusServer::UbusThreadHandler(struct ubus_context      *aContext,
+                                  struct ubus_object       *aObj,
                                   struct ubus_request_data *aRequest,
-                                  const char *              aMethod,
-                                  struct blob_attr *        aMsg,
-                                  const char *              aAction)
+                                  const char               *aMethod,
+                                  struct blob_attr         *aMsg,
+                                  const char               *aAction)
 {
     OT_UNUSED_VARIABLE(aObj);
     OT_UNUSED_VARIABLE(aMethod);
@@ -721,11 +988,11 @@ exit:
     return 0;
 }
 
-int UbusServer::UbusParentHandlerDetail(struct ubus_context *     aContext,
-                                        struct ubus_object *      aObj,
+int UbusServer::UbusParentHandlerDetail(struct ubus_context      *aContext,
+                                        struct ubus_object       *aObj,
                                         struct ubus_request_data *aRequest,
-                                        const char *              aMethod,
-                                        struct blob_attr *        aMsg)
+                                        const char               *aMethod,
+                                        struct blob_attr         *aMsg)
 {
     OT_UNUSED_VARIABLE(aObj);
     OT_UNUSED_VARIABLE(aMethod);
@@ -735,8 +1002,8 @@ int UbusServer::UbusParentHandlerDetail(
     otRouterInfo parentInfo;
     char         extAddress[XPANID_LENGTH] = "";
     char         transfer[XPANID_LENGTH]   = "";
-    void *       jsonList                  = nullptr;
-    void *       jsonArray                 = nullptr;
+    void        *jsonList                  = nullptr;
+    void        *jsonArray                 = nullptr;
 
     blob_buf_init(&mBuf, 0);
 
@@ -767,11 +1034,11 @@ exit:
     return error;
 }
 
-int UbusServer::UbusNeighborHandlerDetail(struct ubus_context *     aContext,
-                                          struct ubus_object *      aObj,
+int UbusServer::UbusNeighborHandlerDetail(struct ubus_context      *aContext,
+                                          struct ubus_object       *aObj,
                                           struct ubus_request_data *aRequest,
-                                          const char *              aMethod,
-                                          struct blob_attr *        aMsg)
+                                          const char               *aMethod,
+                                          struct blob_attr         *aMsg)
 {
     OT_UNUSED_VARIABLE(aObj);
     OT_UNUSED_VARIABLE(aMethod);
@@ -780,14 +1047,14 @@ int UbusServer::UbusNeighborHandlerDetai
     otError                error = OT_ERROR_NONE;
     otNeighborInfo         neighborInfo;
     otNeighborInfoIterator iterator                  = OT_NEIGHBOR_INFO_ITERATOR_INIT;
-    char                   transfer[XPANID_LENGTH]   = "";
-    void *                 jsonList                  = nullptr;
-    char                   mode[5]                   = "";
+    void                  *jsonList                  = nullptr;
     char                   extAddress[XPANID_LENGTH] = "";
+    void                  *pMode                     = nullptr;
+    uint16_t               NeighborNumber            = 0;
 
     blob_buf_init(&mBuf, 0);
 
-    sJsonUri = blobmsg_open_array(&mBuf, "neighbor_list");
+    sJsonUri = blobmsg_open_array(&mBuf, "NeighborList");
 
     mNcpThreadMutex->lock();
     while (otThreadGetNextNeighborInfo(mController->GetInstance(), &iterator, &neighborInfo) == OT_ERROR_NONE)
@@ -796,33 +1063,22 @@ int UbusServer::UbusNeighborHandlerDetai
 
         blobmsg_add_string(&mBuf, "Role", neighborInfo.mIsChild ? "C" : "R");
 
-        sprintf(transfer, "0x%04x", neighborInfo.mRloc16);
-        blobmsg_add_string(&mBuf, "Rloc16", transfer);
-
-        sprintf(transfer, "%3d", neighborInfo.mAge);
-        blobmsg_add_string(&mBuf, "Age", transfer);
+        blobmsg_add_u32(&mBuf, "Rloc16", neighborInfo.mRloc16);
 
-        sprintf(transfer, "%8d", neighborInfo.mAverageRssi);
-        blobmsg_add_string(&mBuf, "AvgRssi", transfer);
+        blobmsg_add_u32(&mBuf, "Age", neighborInfo.mAge);
 
-        sprintf(transfer, "%9d", neighborInfo.mLastRssi);
-        blobmsg_add_string(&mBuf, "LastRssi", transfer);
-
-        if (neighborInfo.mRxOnWhenIdle)
-        {
-            strcat(mode, "r");
-        }
+        blobmsg_add_u32(&mBuf, "AvgRssi", neighborInfo.mAverageRssi);
 
-        if (neighborInfo.mFullThreadDevice)
-        {
-            strcat(mode, "d");
-        }
+        blobmsg_add_u32(&mBuf, "LastRssi", neighborInfo.mLastRssi);
 
-        if (neighborInfo.mFullNetworkData)
+        pMode = blobmsg_open_table(&mBuf, "Mode");
+        if (pMode)
         {
-            strcat(mode, "n");
+            blobmsg_add_u32(&mBuf, "RxOnWhenIdle", neighborInfo.mRxOnWhenIdle);
+            blobmsg_add_u32(&mBuf, "DeviceType", neighborInfo.mFullThreadDevice);
+            blobmsg_add_u32(&mBuf, "NetworkData", neighborInfo.mFullNetworkData);
+            blobmsg_close_table(&mBuf, pMode);
         }
-        blobmsg_add_string(&mBuf, "Mode", mode);
 
         OutputBytes(neighborInfo.mExtAddress.m8, sizeof(neighborInfo.mExtAddress.m8), extAddress);
         blobmsg_add_string(&mBuf, "ExtAddress", extAddress);
@@ -831,11 +1087,12 @@ int UbusServer::UbusNeighborHandlerDetai
 
         blobmsg_close_table(&mBuf, jsonList);
 
-        memset(mode, 0, sizeof(mode));
         memset(extAddress, 0, sizeof(extAddress));
+        NeighborNumber++;
     }
 
     blobmsg_close_array(&mBuf, sJsonUri);
+    blobmsg_add_u32(&mBuf, "NeighborNumber", NeighborNumber);
 
     mNcpThreadMutex->unlock();
 
@@ -843,23 +1100,27 @@ int UbusServer::UbusNeighborHandlerDetai
     return 0;
 }
 
-int UbusServer::UbusMgmtset(struct ubus_context *     aContext,
-                            struct ubus_object *      aObj,
+int UbusServer::UbusMgmtset(struct ubus_context      *aContext,
+                            struct ubus_object       *aObj,
                             struct ubus_request_data *aRequest,
-                            const char *              aMethod,
-                            struct blob_attr *        aMsg)
+                            const char               *aMethod,
+                            struct blob_attr         *aMsg)
 {
     OT_UNUSED_VARIABLE(aObj);
     OT_UNUSED_VARIABLE(aMethod);
     OT_UNUSED_VARIABLE(aMsg);
 
     otError              error = OT_ERROR_NONE;
-    struct blob_attr *   tb[MGMTSET_MAX];
+    struct blob_attr    *tb[MGMTSET_MAX];
     otOperationalDataset dataset;
     uint8_t              tlvs[128];
     long                 value;
     int                  length = 0;
 
+    mNcpThreadMutex->lock();
+
+    blob_buf_init(&mBuf, 0);
+
     SuccessOrExit(error = otDatasetGetActive(mController->GetInstance(), &dataset));
 
     blobmsg_parse(mgmtsetPolicy, MGMTSET_MAX, tb, blob_data(aMsg), blob_len(aMsg));
@@ -917,16 +1178,17 @@ int UbusServer::UbusMgmtset(struct ubus_
                                                      static_cast<uint8_t>(length), /* aCallback */ nullptr,
                                                      /* aContext */ nullptr));
 exit:
+    mNcpThreadMutex->unlock();
     AppendResult(error, aContext, aRequest);
     return 0;
 }
 
-int UbusServer::UbusCommissioner(struct ubus_context *     aContext,
-                                 struct ubus_object *      aObj,
+int UbusServer::UbusCommissioner(struct ubus_context      *aContext,
+                                 struct ubus_object       *aObj,
                                  struct ubus_request_data *aRequest,
-                                 const char *              aMethod,
-                                 struct blob_attr *        aMsg,
-                                 const char *              aAction)
+                                 const char               *aMethod,
+                                 struct blob_attr         *aMsg,
+                                 const char               *aAction)
 {
     OT_UNUSED_VARIABLE(aObj);
     OT_UNUSED_VARIABLE(aMethod);
@@ -934,22 +1196,37 @@ int UbusServer::UbusCommissioner(struct
 
     otError error = OT_ERROR_NONE;
 
-    mNcpThreadMutex->lock();
+    blob_buf_init(&mBuf, 0);
 
+    mNcpThreadMutex->lock();
     if (!strcmp(aAction, "start"))
     {
+        VerifyOrExit(!(otThreadGetDeviceRole(mController->GetInstance()) == OT_DEVICE_ROLE_DISABLED),
+                     error = OT_ERROR_INVALID_STATE);
+
         if (otCommissionerGetState(mController->GetInstance()) == OT_COMMISSIONER_STATE_DISABLED)
         {
             error = otCommissionerStart(mController->GetInstance(), &UbusServer::HandleStateChanged,
                                         &UbusServer::HandleJoinerEvent, this);
         }
     }
+    else if (!strcmp(aAction, "stop"))
+    {
+        error = otCommissionerStop(mController->GetInstance());
+        if (error == OT_ERROR_ALREADY)
+            error = OT_ERROR_NONE;
+    }
+    else if (!strcmp(aAction, "state"))
+    {
+        blobmsg_add_u32(&mBuf, "State", otCommissionerGetState(mController->GetInstance()));
+    }
     else if (!strcmp(aAction, "joineradd"))
     {
-        struct blob_attr *  tb[ADD_JOINER_MAX];
+        struct blob_attr   *tb[ADD_JOINER_MAX];
         otExtAddress        addr;
         const otExtAddress *addrPtr = nullptr;
-        char *              pskd    = nullptr;
+        char               *pskd    = nullptr;
+        unsigned long       timeout = 0;
 
         blobmsg_parse(addJoinerPolicy, ADD_JOINER_MAX, tb, blob_data(aMsg), blob_len(aMsg));
         if (tb[PSKD] != nullptr)
@@ -970,14 +1247,21 @@ int UbusServer::UbusCommissioner(struct
                 addrPtr = &addr;
             }
         }
+        if (tb[TIMEOUT] != nullptr)
+        {
+            timeout = blobmsg_get_u32(tb[TIMEOUT]);
+        }
+        else
+        {
+            timeout = kDefaultJoinerTimeout;
+        }
 
-        unsigned long timeout = kDefaultJoinerTimeout;
         SuccessOrExit(
             error = otCommissionerAddJoiner(mController->GetInstance(), addrPtr, pskd, static_cast<uint32_t>(timeout)));
     }
     else if (!strcmp(aAction, "joinerremove"))
     {
-        struct blob_attr *  tb[SET_NETWORK_MAX];
+        struct blob_attr   *tb[SET_NETWORK_MAX];
         otExtAddress        addr;
         const otExtAddress *addrPtr = nullptr;
 
@@ -1001,7 +1285,6 @@ int UbusServer::UbusCommissioner(struct
 
 exit:
     mNcpThreadMutex->unlock();
-    blob_buf_init(&mBuf, 0);
     AppendResult(error, aContext, aRequest);
     return 0;
 }
@@ -1017,9 +1300,11 @@ void UbusServer::HandleStateChanged(otCo
     {
     case OT_COMMISSIONER_STATE_DISABLED:
         otbrLogInfo("Commissioner state disabled");
+        otbr::ubus::UbusServer::GetInstance().SendEvent(OT_EVENT_OTBR_COMMISSIONER_DISABLED);
         break;
     case OT_COMMISSIONER_STATE_ACTIVE:
         otbrLogInfo("Commissioner state active");
+        otbr::ubus::UbusServer::GetInstance().SendEvent(OT_EVENT_OTBR_COMMISSIONER_ENABLED);
         break;
     case OT_COMMISSIONER_STATE_PETITION:
         otbrLogInfo("Commissioner state petition");
@@ -1028,20 +1313,25 @@ void UbusServer::HandleStateChanged(otCo
 }
 
 void UbusServer::HandleJoinerEvent(otCommissionerJoinerEvent aEvent,
-                                   const otJoinerInfo *      aJoinerInfo,
-                                   const otExtAddress *      aJoinerId,
-                                   void *                    aContext)
+                                   const otJoinerInfo       *aJoinerInfo,
+                                   const otExtAddress       *aJoinerId,
+                                   void                     *aContext)
 {
     static_cast<UbusServer *>(aContext)->HandleJoinerEvent(aEvent, aJoinerInfo, aJoinerId);
 }
 
 void UbusServer::HandleJoinerEvent(otCommissionerJoinerEvent aEvent,
-                                   const otJoinerInfo *      aJoinerInfo,
-                                   const otExtAddress *      aJoinerId)
+                                   const otJoinerInfo       *aJoinerInfo,
+                                   const otExtAddress       *aJoinerId)
 {
     OT_UNUSED_VARIABLE(aJoinerInfo);
     OT_UNUSED_VARIABLE(aJoinerId);
 
+    char sEUI64[17]    = {0};
+    char sUciPath[128] = {0};
+    if (aJoinerInfo->mType == OT_JOINER_INFO_TYPE_EUI64)
+        OutputBytes(aJoinerInfo->mSharedId.mEui64.m8, OT_EXT_ADDRESS_SIZE, sEUI64);
+
     switch (aEvent)
     {
     case OT_COMMISSIONER_JOINER_START:
@@ -1052,22 +1342,32 @@ void UbusServer::HandleJoinerEvent(otCom
         break;
     case OT_COMMISSIONER_JOINER_FINALIZE:
         otbrLogInfo("Joiner finalize");
+        if (aJoinerInfo->mType == OT_JOINER_INFO_TYPE_EUI64)
+        {
+            sprintf(sUciPath, "thread_devices.%s.Joined", sEUI64);
+            otbr::Utils::UciSet(sUciPath, (char *)"1");
+        }
         break;
     case OT_COMMISSIONER_JOINER_END:
         otbrLogInfo("Joiner end");
         break;
     case OT_COMMISSIONER_JOINER_REMOVED:
         otbrLogInfo("Joiner remove");
+        if (aJoinerInfo->mType == OT_JOINER_INFO_TYPE_EUI64)
+        {
+            sprintf(sUciPath, "thread_devices.%s.status", sEUI64);
+            otbr::Utils::UciDel(sUciPath);
+        }
         break;
     }
 }
 
-int UbusServer::UbusGetInformation(struct ubus_context *     aContext,
-                                   struct ubus_object *      aObj,
+int UbusServer::UbusGetInformation(struct ubus_context      *aContext,
+                                   struct ubus_object       *aObj,
                                    struct ubus_request_data *aRequest,
-                                   const char *              aMethod,
-                                   struct blob_attr *        aMsg,
-                                   const char *              aAction)
+                                   const char               *aMethod,
+                                   struct blob_attr         *aMsg,
+                                   const char               *aAction)
 {
     OT_UNUSED_VARIABLE(aObj);
     OT_UNUSED_VARIABLE(aMethod);
@@ -1197,12 +1497,12 @@ int UbusServer::UbusGetInformation(struc
     }
     else if (!strcmp(aAction, "joinernum"))
     {
-        void *       jsonTable = nullptr;
-        void *       jsonArray = nullptr;
+        void        *jsonTable = nullptr;
+        void        *jsonArray = nullptr;
         otJoinerInfo joinerInfo;
-        uint16_t     iterator        = 0;
-        int          joinerNum       = 0;
-        char         eui64[EXTPANID] = "";
+        uint16_t     iterator  = 0;
+        int          joinerNum = 0;
+        char         eui64[17] = "";
 
         blob_buf_init(&mBuf, 0);
 
@@ -1214,6 +1514,7 @@ int UbusServer::UbusGetInformation(struc
             jsonTable = blobmsg_open_table(&mBuf, nullptr);
 
             blobmsg_add_string(&mBuf, "pskd", joinerInfo.mPskd.m8);
+            blobmsg_add_u64(&mBuf, "expiration_time", joinerInfo.mExpirationTime);
 
             switch (joinerInfo.mType)
             {
@@ -1237,7 +1538,7 @@ int UbusServer::UbusGetInformation(struc
             joinerNum++;
         }
         blobmsg_close_array(&mBuf, jsonArray);
-
+        blobmsg_add_u32(&mBuf, "joinernum_max", OPENTHREAD_CONFIG_COMMISSIONER_MAX_JOINER_ENTRIES);
         blobmsg_add_u32(&mBuf, "joinernum", joinerNum);
     }
     else if (!strcmp(aAction, "macfilterstate"))
@@ -1281,6 +1582,470 @@ int UbusServer::UbusGetInformation(struc
 
         blobmsg_close_array(&mBuf, sJsonUri);
     }
+    else if (!strcmp(aAction, "status"))
+    {
+        blobmsg_add_u16(&mBuf, "OpenThreadVersionAPI", OPENTHREAD_API_VERSION);
+        blobmsg_add_string(&mBuf, "OTBRVersion", otGetVersionString());
+        if (otThreadGetVersion() == 4)
+            blobmsg_add_string(&mBuf, "ThreadVersion", "v1.3");
+        else if (otThreadGetVersion() == 3)
+            blobmsg_add_string(&mBuf, "ThreadVersion", "v1.2");
+        else if (otThreadGetVersion() == 2)
+            blobmsg_add_string(&mBuf, "ThreadVersion", "v1.1");
+        else
+            blobmsg_add_string(&mBuf, "ThreadVersion", "unknown");
+
+        char extPanId[17]    = {0};
+        char networkKey[33]  = {0};
+        char PSKc[33]        = {0};
+        char extAddress[17]  = {0};
+        char passphrase[256] = {0};
+
+        char activeDataset[OT_OPERATIONAL_DATASET_MAX_LENGTH] = {0};
+
+        uint8_t rloc = otThreadGetDeviceRole(mController->GetInstance());
+
+        /* Network Item */
+        void *pNetwork = NULL;
+        pNetwork       = blobmsg_open_table(&mBuf, "Network");
+        blobmsg_add_u16(&mBuf, "Channel", otLinkGetChannel(mController->GetInstance()));
+
+        const uint8_t *pExtPanId =
+            reinterpret_cast<const uint8_t *>(otThreadGetExtendedPanId(mController->GetInstance()));
+        OutputBytes(pExtPanId, OT_EXT_PAN_ID_SIZE, extPanId);
+        blobmsg_add_string(&mBuf, "ExtPanId", extPanId);
+
+        otNetworkKey t_networkKey;
+        otThreadGetNetworkKey(mController->GetInstance(), &t_networkKey);
+        const uint8_t *pNetworkKey = reinterpret_cast<const uint8_t *>(t_networkKey.m8);
+        OutputBytes(pNetworkKey, OT_NETWORK_KEY_SIZE, networkKey);
+        blobmsg_add_string(&mBuf, "NetworkKey", networkKey);
+
+        blobmsg_add_string(&mBuf, "NetworkName", otThreadGetNetworkName(mController->GetInstance()));
+        blobmsg_add_u32(&mBuf, "PanId", otLinkGetPanId(mController->GetInstance()));
+
+        otPskc t_pskc;
+        otThreadGetPskc(mController->GetInstance(), &t_pskc);
+        const uint8_t *pPSKc = reinterpret_cast<const uint8_t *>(t_pskc.m8);
+        OutputBytes(pPSKc, OT_PSKC_MAX_SIZE, PSKc);
+        blobmsg_add_string(&mBuf, "PSKc", PSKc);
+
+        otbr::Utils::UciGet("otbr.otbr.passphrase", passphrase);
+        if (strlen(passphrase) != 0)
+            blobmsg_add_string(&mBuf, "Passphrase", passphrase);
+        // DefaultRouter
+        void *pOnMeshPrefix = nullptr;
+        pOnMeshPrefix       = blobmsg_open_array(&mBuf, "OnMeshPrefix");
+        if (pOnMeshPrefix)
+        {
+            otNetworkDataIterator iterator = OT_NETWORK_DATA_ITERATOR_INIT;
+            otBorderRouterConfig  config;
+            while (otNetDataGetNextOnMeshPrefix(mController->GetInstance(), &iterator, &config) == OT_ERROR_NONE)
+            {
+                char str[OT_IP6_ADDRESS_STRING_SIZE] = {0};
+                otIp6PrefixToString(&config.mPrefix, str, sizeof(str));
+                blobmsg_add_string(&mBuf, nullptr, str);
+            }
+            blobmsg_close_array(&mBuf, pOnMeshPrefix);
+        }
+
+        if (rloc != OT_DEVICE_ROLE_DISABLED && rloc != OT_DEVICE_ROLE_DETACHED)
+        {
+            void        *pLeaderdata = NULL;
+            otLeaderData leaderData;
+
+            pLeaderdata = blobmsg_open_table(&mBuf, "LeaderData");
+            if (pLeaderdata)
+            {
+                otThreadGetLeaderData(mController->GetInstance(), &leaderData);
+                blobmsg_add_u32(&mBuf, "PartitionId", leaderData.mPartitionId);
+                blobmsg_add_u32(&mBuf, "Weighting", leaderData.mWeighting);
+                blobmsg_add_u32(&mBuf, "DataVersion", leaderData.mDataVersion);
+                blobmsg_add_u32(&mBuf, "StableDataVersion", leaderData.mStableDataVersion);
+                blobmsg_add_u32(&mBuf, "LeaderRouterId", leaderData.mLeaderRouterId);
+                blobmsg_close_table(&mBuf, pLeaderdata);
+            }
+        }
+
+        char                     meshLocalPrefix[32] = {0};
+        const otMeshLocalPrefix *aPrefix             = otThreadGetMeshLocalPrefix(mController->GetInstance());
+        if (aPrefix != NULL)
+        {
+            sprintf(meshLocalPrefix, "%x:%x:%x:%x:", (aPrefix->m8[0] << 8) | aPrefix->m8[1],
+                    (aPrefix->m8[2] << 8) | aPrefix->m8[3], (aPrefix->m8[4] << 8) | aPrefix->m8[5],
+                    (aPrefix->m8[6] << 8) | aPrefix->m8[7]);
+            blobmsg_add_string(&mBuf, "MeshLocalPrefix", meshLocalPrefix);
+        }
+
+        void *pIPv6 = NULL;
+        pIPv6       = blobmsg_open_table(&mBuf, "IPv6");
+        if (pIPv6)
+        {
+            const otNetifAddress *unicastAddrs = otIp6GetUnicastAddresses(mController->GetInstance());
+            for (const otNetifAddress *addr = unicastAddrs; addr; addr = addr->mNext)
+            {
+                char string[OT_IP6_ADDRESS_STRING_SIZE];
+                otIp6AddressToString(&addr->mAddress, string, sizeof(string));
+                blobmsg_add_string(&mBuf, nullptr, string);
+            }
+            blobmsg_close_table(&mBuf, pIPv6);
+        }
+
+        otOperationalDatasetTlvs dataset;
+        otDatasetGetActiveTlvs(mController->GetInstance(), &dataset);
+        OutputBytes(dataset.mTlvs, dataset.mLength, activeDataset);
+        blobmsg_add_string(&mBuf, "ActiveDataset", activeDataset);
+
+        blobmsg_close_table(&mBuf, pNetwork);
+
+        /* RCP Item */
+        void *pRCP = NULL;
+        pRCP       = blobmsg_open_table(&mBuf, "RCP");
+        if (pRCP)
+        {
+            if (rloc == OT_DEVICE_ROLE_DISABLED)
+                blobmsg_add_u16(&mBuf, "State", 0);
+            else if (rloc == OT_DEVICE_ROLE_DETACHED)
+                blobmsg_add_u16(&mBuf, "State", 1);
+            else if (rloc == OT_DEVICE_ROLE_CHILD)
+                blobmsg_add_u16(&mBuf, "State", 2);
+            else if (rloc == OT_DEVICE_ROLE_ROUTER)
+                blobmsg_add_u16(&mBuf, "State", 3);
+            else if (rloc == OT_DEVICE_ROLE_LEADER)
+                blobmsg_add_u16(&mBuf, "State", 4);
+            const uint8_t *pExtAddress =
+                reinterpret_cast<const uint8_t *>(otLinkGetExtendedAddress(mController->GetInstance()));
+            OutputBytes(pExtAddress, OT_EXT_ADDRESS_SIZE, extAddress);
+            blobmsg_add_string(&mBuf, "ExtAddress", extAddress);
+            blobmsg_add_u32(&mBuf, "Rloc16", otThreadGetRloc16(mController->GetInstance()));
+            blobmsg_close_table(&mBuf, pRCP);
+        }
+
+        /* SRP Item */
+        void *pSRP = NULL;
+        pSRP       = blobmsg_open_table(&mBuf, "SRP");
+        if (pSRP)
+        {
+            blobmsg_add_u32(&mBuf, "ServerState", otSrpServerGetState(mController->GetInstance()));
+            blobmsg_add_string(&mBuf, "ServerDomain", otSrpServerGetDomain(mController->GetInstance()));
+            blobmsg_close_table(&mBuf, pSRP);
+        }
+
+        /* Commissioner Item*/
+        void *pCommissioner = NULL;
+        pCommissioner       = blobmsg_open_table(&mBuf, "Commissioner");
+        if (pCommissioner)
+        {
+            blobmsg_add_u32(&mBuf, "State", otCommissionerGetState(mController->GetInstance()));
+            blobmsg_close_table(&mBuf, pCommissioner);
+        }
+    }
+    else if (!strcmp(aAction, "networkdiagnostic"))
+    {
+        ubus_send_reply(aContext, aRequest, mNetworkDiagnosticDataBuf.head);
+        if (time(nullptr) - mSecond > 10)
+        {
+            struct otIp6Address address;
+            const uint8_t       kAllTlvTypes[]    = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 14, 15, 16, 17, 18, 19};
+            char                multicastAddr[10] = "ff03::2";
+
+            memset(&mNetworkDiagnosticDataBuf, 0, sizeof(mNetworkDiagnosticDataBuf));
+            blob_buf_init(&mNetworkDiagnosticDataBuf, 0);
+
+            SuccessOrExit(error = otIp6AddressFromString(multicastAddr, &address));
+
+            sBufNum = 0;
+            otThreadSendDiagnosticGet(mController->GetInstance(), &address, kAllTlvTypes, sizeof(kAllTlvTypes),
+                                      &UbusServer::ExtHandleDiagnosticGetResponse, this);
+            mSecond = time(nullptr);
+        }
+        goto exit;
+    }
+    else if (!strcmp(aAction, "txpower"))
+    {
+        int8_t power;
+        otPlatRadioGetTransmitPower(mController->GetInstance(), &power);
+        blobmsg_add_u32(&mBuf, "TXPower", power);
+    }
+    else if (!strcmp(aAction, "thread_join_state"))
+    {
+        blobmsg_add_u32(&mBuf, "State", otJoinerGetState(mController->GetInstance()));
+    }
+#if OTBR_ENABLE_BACKBONE_ROUTER
+    else if (!strcmp(aAction, "bbrstatus"))
+    {
+        switch (otBackboneRouterGetState(mController->GetInstance()))
+        {
+        case OT_BACKBONE_ROUTER_STATE_DISABLED:
+            blobmsg_add_string(&mBuf, "State", "Disabled");
+            break;
+        case OT_BACKBONE_ROUTER_STATE_SECONDARY:
+            blobmsg_add_string(&mBuf, "State", "Secondary");
+            break;
+        case OT_BACKBONE_ROUTER_STATE_PRIMARY:
+            blobmsg_add_string(&mBuf, "State", "Primary");
+            break;
+        default:
+            blobmsg_add_string(&mBuf, "State", "Disabled");
+            break;
+        }
+
+        otBackboneRouterConfig config;
+        if (otBackboneRouterGetPrimary(mController->GetInstance(), &config) == OT_ERROR_NONE)
+        {
+            blobmsg_add_u32(&mBuf, "MlrTimeout", config.mMlrTimeout);
+            blobmsg_add_u32(&mBuf, "SequenceNumber", config.mReregistrationDelay);
+            blobmsg_add_u32(&mBuf, "ReregistrationDelay", config.mReregistrationDelay);
+            blobmsg_add_u32(&mBuf, "Jitter", otBackboneRouterGetRegistrationJitter(mController->GetInstance()));
+        }
+    }
+#endif
+    else if (!strcmp(aAction, "srpsrvconfig"))
+    {
+        otSrpServerLeaseConfig leaseConfig;
+        otSrpServerGetLeaseConfig(mController->GetInstance(), &leaseConfig);
+        blobmsg_add_u32(&mBuf, "MinLease", leaseConfig.mMinLease);
+        blobmsg_add_u32(&mBuf, "MaxLease", leaseConfig.mMaxLease);
+        blobmsg_add_u32(&mBuf, "MinKeyLease", leaseConfig.mMinKeyLease);
+        blobmsg_add_u32(&mBuf, "MaxKeyLease", leaseConfig.mMaxKeyLease);
+        blobmsg_add_u8(&mBuf, "Enable", (otSrpServerGetState(mController->GetInstance()) == 1) ? true : false);
+        blobmsg_add_string(&mBuf, "DomainName", otSrpServerGetDomain(mController->GetInstance()));
+        blobmsg_add_u32(&mBuf, "SeqNum", otSrpServerGetAnycastModeSequenceNumber(mController->GetInstance()));
+    }
+    else if (!strcmp(aAction, "srpsrvservice"))
+    {
+        static constexpr char *kAnyServiceName  = nullptr;
+        static constexpr char *kAnyInstanceName = nullptr;
+
+        const otSrpServerHost *host = nullptr;
+
+        void *pServices = nullptr;
+        pServices       = blobmsg_open_array(&mBuf, "Services");
+
+        while ((host = otSrpServerGetNextHost(mController->GetInstance(), host)) != nullptr)
+        {
+            const otSrpServerService *service = nullptr;
+
+            while ((service = otSrpServerHostFindNextService(host, service, OT_SRP_SERVER_FLAGS_BASE_TYPE_SERVICE_ONLY,
+                                                             kAnyServiceName, kAnyInstanceName)) != nullptr)
+            {
+                bool                      isDeleted    = otSrpServerServiceIsDeleted(service);
+                const char               *instanceName = otSrpServerServiceGetInstanceName(service);
+                const otSrpServerService *subService   = nullptr;
+                const uint8_t            *txtData;
+                uint16_t                  txtDataLength;
+                bool                      hasSubType = false;
+                otSrpServerLeaseInfo      leaseInfo;
+
+                void *pService = blobmsg_open_table(&mBuf, nullptr);
+                if (pService)
+                {
+                    blobmsg_add_string(&mBuf, "InstanceName", instanceName);
+                    blobmsg_add_u8(&mBuf, "Deleted", isDeleted);
+
+                    if (isDeleted)
+                    {
+                        blobmsg_close_table(&mBuf, pService);
+                        continue;
+                    }
+
+                    otSrpServerServiceGetLeaseInfo(service, &leaseInfo);
+                    blobmsg_add_u32(&mBuf, "Lease", leaseInfo.mLease / 1000);
+                    blobmsg_add_u32(&mBuf, "KeyLease", leaseInfo.mKeyLease / 1000);
+
+                    char subtypes[256] = {0};
+                    while ((subService = otSrpServerHostFindNextService(
+                                host, subService,
+                                (OT_SRP_SERVER_SERVICE_FLAG_SUB_TYPE | OT_SRP_SERVER_SERVICE_FLAG_ACTIVE),
+                                kAnyServiceName, instanceName)) != nullptr)
+                    {
+                        char subLabel[OT_DNS_MAX_LABEL_SIZE];
+                        otSrpServerServiceGetServiceSubTypeLabel(subService, subLabel, sizeof(subLabel));
+                        if (!hasSubType)
+                        {
+                            strcat(subtypes, subLabel);
+                        }
+                        else
+                        {
+                            strcat(subtypes, ",");
+                            strcat(subtypes, subLabel);
+                        }
+                        hasSubType = true;
+                    }
+                    blobmsg_add_string(&mBuf, "Subtypes", subtypes);
+
+                    blobmsg_add_u32(&mBuf, "Port", otSrpServerServiceGetPort(service));
+                    blobmsg_add_u32(&mBuf, "Priority", otSrpServerServiceGetPriority(service));
+                    blobmsg_add_u32(&mBuf, "Weight", otSrpServerServiceGetWeight(service));
+                    blobmsg_add_u32(&mBuf, "Ttl", otSrpServerServiceGetTtl(service));
+
+                    txtData = otSrpServerServiceGetTxtData(service, &txtDataLength);
+                    if (txtDataLength > 0)
+                    {
+                        otDnsTxtEntry         entry;
+                        otDnsTxtEntryIterator iterator;
+
+                        void *pTXT = blobmsg_open_array(&mBuf, "TXT");
+                        if (pTXT)
+                        {
+                            otDnsInitTxtEntryIterator(&iterator, txtData, txtDataLength);
+
+                            while (otDnsGetNextTxtEntry(&iterator, &entry) == OT_ERROR_NONE)
+                            {
+                                char item[256] = {0};
+                                if (entry.mKey == nullptr)
+                                {
+                                    OutputBytes(entry.mValue, entry.mValueLength, item);
+                                }
+                                else
+                                {
+                                    strcat(item, entry.mKey);
+
+                                    if (entry.mValue != nullptr)
+                                    {
+                                        char value[256] = {0};
+                                        strcat(item, "=");
+                                        OutputBytes(entry.mValue, entry.mValueLength, value);
+                                        strcat(item, value);
+                                    }
+                                }
+                                blobmsg_add_string(&mBuf, nullptr, item);
+                            }
+                            blobmsg_close_array(&mBuf, pTXT);
+                        }
+                    }
+
+                    blobmsg_add_string(&mBuf, "Host", otSrpServerHostGetFullName(host));
+
+                    void *pAddress = NULL;
+                    pAddress       = blobmsg_open_array(&mBuf, "Address");
+                    if (pAddress)
+                    {
+                        const otIp6Address *addresses;
+                        uint8_t             addressesNum;
+
+                        addresses = otSrpServerHostGetAddresses(host, &addressesNum);
+
+                        for (uint8_t i = 0; i < addressesNum; ++i)
+                        {
+                            char string[OT_IP6_ADDRESS_STRING_SIZE];
+                            otIp6AddressToString(&addresses[i], string, sizeof(string));
+                            blobmsg_add_string(&mBuf, nullptr, string);
+                        }
+                        blobmsg_close_array(&mBuf, pAddress);
+                    }
+                    blobmsg_close_table(&mBuf, pService);
+                }
+            }
+        }
+        blobmsg_close_array(&mBuf, pServices);
+    }
+    else if (!strcmp(aAction, "localaddr"))
+    {
+        char address[OT_IP6_ADDRESS_STRING_SIZE];
+
+        memset(address, 0, sizeof(address));
+
+        const otNetifAddress *unicastAddrs = otIp6GetUnicastAddresses(mController->GetInstance());
+        for (const otNetifAddress *addr = unicastAddrs; addr; addr = addr->mNext)
+        {
+            if (addr->mAddressOrigin == OT_ADDRESS_ORIGIN_SLAAC)
+            {
+                otIp6AddressToString(&addr->mAddress, address, sizeof(address));
+                break;
+            }
+        }
+
+        blobmsg_add_string(&mBuf, "localaddr", address);
+    }
+    else if (!strcmp(aAction, "activetimestamp"))
+    {
+        otOperationalDataset dataset;
+        SuccessOrExit(error = otDatasetGetActive(mController->GetInstance(), &dataset));
+        blobmsg_add_u64(&mBuf, "ActiveTimestamp", dataset.mActiveTimestamp.mSeconds);
+    }
+    else if (!strcmp(aAction, "bufferinfo"))
+    {
+        otBufferInfo bufferInfo;
+        otMessageGetBufferInfo(mController->GetInstance(), &bufferInfo);
+
+        blobmsg_add_u32(&mBuf, "TotalBuffers", bufferInfo.mTotalBuffers);
+        blobmsg_add_u32(&mBuf, "FreeBuffers", bufferInfo.mFreeBuffers);
+
+        blobmsg_add_u32(&mBuf, "6loSendQueue.NumMessages", bufferInfo.m6loSendQueue.mNumMessages);
+        blobmsg_add_u32(&mBuf, "6loSendQueue.NumBuffers", bufferInfo.m6loSendQueue.mNumBuffers);
+        blobmsg_add_u32(&mBuf, "6loSendQueue.TotalBytes", bufferInfo.m6loSendQueue.mTotalBytes);
+
+        blobmsg_add_u32(&mBuf, "6loReassemblyQueue.NumMessages", bufferInfo.m6loReassemblyQueue.mNumMessages);
+        blobmsg_add_u32(&mBuf, "6loReassemblyQueue.NumBuffers", bufferInfo.m6loReassemblyQueue.mNumBuffers);
+        blobmsg_add_u32(&mBuf, "6loReassemblyQueue.TotalBytes", bufferInfo.m6loReassemblyQueue.mTotalBytes);
+
+        blobmsg_add_u32(&mBuf, "Ip6Queue.NumMessages", bufferInfo.mIp6Queue.mNumMessages);
+        blobmsg_add_u32(&mBuf, "Ip6Queue.NumBuffers", bufferInfo.mIp6Queue.mNumBuffers);
+        blobmsg_add_u32(&mBuf, "Ip6Queue.TotalBytes", bufferInfo.mIp6Queue.mTotalBytes);
+
+        blobmsg_add_u32(&mBuf, "MplQueue.NumMessages", bufferInfo.mMplQueue.mNumMessages);
+        blobmsg_add_u32(&mBuf, "MplQueue.NumBuffers", bufferInfo.mMplQueue.mNumBuffers);
+        blobmsg_add_u32(&mBuf, "MplQueue.TotalBytes", bufferInfo.mMplQueue.mTotalBytes);
+
+        blobmsg_add_u32(&mBuf, "MleQueue.NumMessages", bufferInfo.mMleQueue.mNumMessages);
+        blobmsg_add_u32(&mBuf, "MleQueue.NumBuffers", bufferInfo.mMleQueue.mNumBuffers);
+        blobmsg_add_u32(&mBuf, "MleQueue.TotalBytes", bufferInfo.mMleQueue.mTotalBytes);
+
+        blobmsg_add_u32(&mBuf, "CoapQueue.NumMessages", bufferInfo.mCoapQueue.mNumMessages);
+        blobmsg_add_u32(&mBuf, "CoapQueue.NumBuffers", bufferInfo.mCoapQueue.mNumBuffers);
+        blobmsg_add_u32(&mBuf, "CoapQueue.TotalBytes", bufferInfo.mCoapQueue.mTotalBytes);
+
+        blobmsg_add_u32(&mBuf, "CoapSecureQueue.NumMessages", bufferInfo.mCoapSecureQueue.mNumMessages);
+        blobmsg_add_u32(&mBuf, "CoapSecureQueue.NumBuffers", bufferInfo.mCoapSecureQueue.mNumBuffers);
+        blobmsg_add_u32(&mBuf, "CoapSecureQueue.TotalBytes", bufferInfo.mCoapSecureQueue.mTotalBytes);
+
+        blobmsg_add_u32(&mBuf, "ApplicationCoapQueue.NumMessages", bufferInfo.mApplicationCoapQueue.mNumMessages);
+        blobmsg_add_u32(&mBuf, "ApplicationCoapQueue.NumBuffers", bufferInfo.mApplicationCoapQueue.mNumBuffers);
+        blobmsg_add_u32(&mBuf, "ApplicationCoapQueue.TotalBytes", bufferInfo.mApplicationCoapQueue.mTotalBytes);
+    }
+    else if (!strcmp(aAction, "services"))
+    {
+        otNetworkDataIterator iterator = OT_NETWORK_DATA_ITERATOR_INIT;
+        otServiceConfig       config;
+
+        void *pServices = nullptr;
+        pServices       = blobmsg_open_array(&mBuf, "Services");
+        if (pServices)
+        {
+            while (otNetDataGetNextService(mController->GetInstance(), &iterator, &config) == OT_ERROR_NONE)
+            {
+                void *pService = blobmsg_open_table(&mBuf, nullptr);
+                if (pService)
+                {
+                    char aServicesData[64] = {0};
+                    char aServerData[64]   = {0};
+
+                    blobmsg_add_u16(&mBuf, "ServiceId", config.mServiceId);
+                    blobmsg_add_u32(&mBuf, "EnterpriseNumber", config.mEnterpriseNumber);
+                    blobmsg_add_u16(&mBuf, "ServiceDataLength", config.mServiceDataLength);
+                    OutputBytes(config.mServiceData, config.mServiceDataLength, aServicesData);
+                    blobmsg_add_string(&mBuf, "ServicesData", aServicesData);
+                    if (!strcmp(aServicesData, "01"))
+                    {
+                        blobmsg_add_string(&mBuf, "ServicesName", "BBR");
+                    }
+                    else if (!strcmp(aServicesData, "5d"))
+                    {
+                        blobmsg_add_string(&mBuf, "ServicesName", "SRP server");
+                    }
+
+                    blobmsg_add_u16(&mBuf, "ServerDataLength", config.mServerConfig.mServerDataLength);
+                    OutputBytes(config.mServerConfig.mServerData, config.mServerConfig.mServerDataLength, aServerData);
+                    blobmsg_add_string(&mBuf, "ServerData", aServerData);
+                    blobmsg_add_u8(&mBuf, "Stable", config.mServerConfig.mStable);
+                    blobmsg_add_u32(&mBuf, "Rloc16", config.mServerConfig.mRloc16);
+                    blobmsg_close_table(&mBuf, pService);
+                }
+            }
+            blobmsg_close_table(&mBuf, pServices);
+        }
+    }
     else
     {
         perror("invalid argument in get information ubus\n");
@@ -1293,9 +2058,9 @@ exit:
 }
 
 void UbusServer::HandleDiagnosticGetResponse(otError              aError,
-                                             otMessage *          aMessage,
+                                             otMessage           *aMessage,
                                              const otMessageInfo *aMessageInfo,
-                                             void *               aContext)
+                                             void                *aContext)
 {
     static_cast<UbusServer *>(aContext)->HandleDiagnosticGetResponse(aError, aMessage, aMessageInfo);
 }
@@ -1316,8 +2081,8 @@ void UbusServer::HandleDiagnosticGetResp
 {
     uint16_t              rloc16;
     uint16_t              sockRloc16 = 0;
-    void *                jsonArray  = nullptr;
-    void *                jsonItem   = nullptr;
+    void                 *jsonArray  = nullptr;
+    void                 *jsonItem   = nullptr;
     char                  xrloc[10];
     otNetworkDiagTlv      diagTlv;
     otNetworkDiagIterator iterator = OT_NETWORK_DIAGNOSTIC_ITERATOR_INIT;
@@ -1409,12 +2174,229 @@ exit:
     }
 }
 
-int UbusServer::UbusSetInformation(struct ubus_context *     aContext,
-                                   struct ubus_object *      aObj,
+void UbusServer::ExtHandleDiagnosticGetResponse(otError              aError,
+                                                otMessage           *aMessage,
+                                                const otMessageInfo *aMessageInfo,
+                                                void                *aContext)
+{
+    static_cast<UbusServer *>(aContext)->ExtHandleDiagnosticGetResponse(aError, aMessage, aMessageInfo);
+}
+
+void UbusServer::ExtHandleDiagnosticGetResponse(otError aError, otMessage *aMessage, const otMessageInfo *aMessageInfo)
+{
+    void                 *jsonArray = nullptr;
+    void                 *jsonItem  = nullptr;
+    otNetworkDiagTlv      diagTlv;
+    otNetworkDiagIterator iterator = OT_NETWORK_DIAGNOSTIC_ITERATOR_INIT;
+
+    SuccessOrExit(aError);
+
+    char networkdata[20];
+    sprintf(networkdata, "networkdata%d", sBufNum);
+    sJsonUri = blobmsg_open_table(&mNetworkDiagnosticDataBuf, NULL);
+    sBufNum++;
+
+    OT_UNUSED_VARIABLE(aMessageInfo);
+    // if (IsRoutingLocator(&aMessageInfo->mSockAddr))
+    // {
+    //     blobmsg_add_u32(&mNetworkDiagnosticDataBuf, "Rloc16", ntohs(aMessageInfo->mPeerAddr.mFields.m16[7]));
+    // }
+
+    while (otThreadGetNextDiagnosticTlv(aMessage, &iterator, &diagTlv) == OT_ERROR_NONE)
+    {
+        switch (diagTlv.mType)
+        {
+        case OT_NETWORK_DIAGNOSTIC_TLV_EXT_ADDRESS:
+        {
+            char extaddr[20];
+            sprintf(extaddr, "%02x%02x%02x%02x%02x%02x%02x%02x", diagTlv.mData.mExtAddress.m8[0],
+                    diagTlv.mData.mExtAddress.m8[1], diagTlv.mData.mExtAddress.m8[2], diagTlv.mData.mExtAddress.m8[3],
+                    diagTlv.mData.mExtAddress.m8[4], diagTlv.mData.mExtAddress.m8[5], diagTlv.mData.mExtAddress.m8[6],
+                    diagTlv.mData.mExtAddress.m8[7]);
+            blobmsg_add_string(&mNetworkDiagnosticDataBuf, "ExtAddress", extaddr);
+            break;
+        }
+        case OT_NETWORK_DIAGNOSTIC_TLV_SHORT_ADDRESS:
+        {
+            blobmsg_add_u32(&mNetworkDiagnosticDataBuf, "Rloc16", diagTlv.mData.mAddr16);
+            break;
+        }
+        case OT_NETWORK_DIAGNOSTIC_TLV_MODE:
+        {
+            jsonItem = blobmsg_open_table(&mNetworkDiagnosticDataBuf, "Mode");
+            blobmsg_add_u16(&mNetworkDiagnosticDataBuf, "RxOnWhenIdle", diagTlv.mData.mMode.mRxOnWhenIdle);
+            blobmsg_add_u16(&mNetworkDiagnosticDataBuf, "DeviceType", diagTlv.mData.mMode.mDeviceType);
+            blobmsg_add_u16(&mNetworkDiagnosticDataBuf, "NetworkData", diagTlv.mData.mMode.mNetworkData);
+            blobmsg_close_table(&mNetworkDiagnosticDataBuf, jsonItem);
+            break;
+        }
+        case OT_NETWORK_DIAGNOSTIC_TLV_TIMEOUT:
+        {
+            blobmsg_add_u8(&mNetworkDiagnosticDataBuf, "Timeout", diagTlv.mData.mTimeout);
+            break;
+        }
+        case OT_NETWORK_DIAGNOSTIC_TLV_CONNECTIVITY:
+        {
+            jsonItem = blobmsg_open_table(&mNetworkDiagnosticDataBuf, "Connectivity");
+            blobmsg_add_u16(&mNetworkDiagnosticDataBuf, "ParentPriority", diagTlv.mData.mConnectivity.mParentPriority);
+            blobmsg_add_u16(&mNetworkDiagnosticDataBuf, "LinkQuality3", diagTlv.mData.mConnectivity.mLinkQuality3);
+            blobmsg_add_u16(&mNetworkDiagnosticDataBuf, "LinkQuality2", diagTlv.mData.mConnectivity.mLinkQuality2);
+            blobmsg_add_u16(&mNetworkDiagnosticDataBuf, "LinkQuality1", diagTlv.mData.mConnectivity.mLinkQuality1);
+            blobmsg_add_u16(&mNetworkDiagnosticDataBuf, "LeaderCost", diagTlv.mData.mConnectivity.mLeaderCost);
+            blobmsg_add_u16(&mNetworkDiagnosticDataBuf, "IdSequence", diagTlv.mData.mConnectivity.mIdSequence);
+            blobmsg_add_u16(&mNetworkDiagnosticDataBuf, "ActiveRouters", diagTlv.mData.mConnectivity.mActiveRouters);
+            blobmsg_add_u16(&mNetworkDiagnosticDataBuf, "SedBufferSize", diagTlv.mData.mConnectivity.mSedBufferSize);
+            blobmsg_add_u16(&mNetworkDiagnosticDataBuf, "SedDatagramCount",
+                            diagTlv.mData.mConnectivity.mSedDatagramCount);
+            blobmsg_close_table(&mNetworkDiagnosticDataBuf, jsonItem);
+            break;
+        }
+        case OT_NETWORK_DIAGNOSTIC_TLV_ROUTE:
+        {
+            const otNetworkDiagRoute &route = diagTlv.mData.mRoute;
+
+            jsonItem = blobmsg_open_table(&mNetworkDiagnosticDataBuf, "Route");
+            blobmsg_add_u16(&mNetworkDiagnosticDataBuf, "IdSequence", route.mIdSequence);
+
+            jsonArray = blobmsg_open_array(&mNetworkDiagnosticDataBuf, "RouteData");
+
+            for (uint16_t i = 0; i < route.mRouteCount; ++i)
+            {
+                uint8_t in, out;
+                in  = route.mRouteData[i].mLinkQualityIn;
+                out = route.mRouteData[i].mLinkQualityOut;
+                if (in != 0 && out != 0)
+                {
+                    void *t = nullptr;
+                    t       = blobmsg_open_table(&mNetworkDiagnosticDataBuf, "router");
+                    blobmsg_add_u32(&mNetworkDiagnosticDataBuf, "RouteId", route.mRouteData[i].mRouterId);
+                    blobmsg_add_u32(&mNetworkDiagnosticDataBuf, "LinkQualityOut", out);
+                    blobmsg_add_u32(&mNetworkDiagnosticDataBuf, "LinkQualityIn", in);
+                    blobmsg_add_u32(&mNetworkDiagnosticDataBuf, "RouteCost", route.mRouteData[i].mRouteCost);
+                    blobmsg_close_table(&mNetworkDiagnosticDataBuf, t);
+                }
+            }
+            blobmsg_close_array(&mNetworkDiagnosticDataBuf, jsonArray);
+            blobmsg_close_table(&mNetworkDiagnosticDataBuf, jsonItem);
+            break;
+        }
+        case OT_NETWORK_DIAGNOSTIC_TLV_LEADER_DATA:
+        {
+            jsonItem = blobmsg_open_table(&mNetworkDiagnosticDataBuf, "LeaderData");
+            blobmsg_add_u32(&mNetworkDiagnosticDataBuf, "PartitionId", diagTlv.mData.mLeaderData.mPartitionId);
+            blobmsg_add_u16(&mNetworkDiagnosticDataBuf, "Weighting", diagTlv.mData.mLeaderData.mWeighting);
+            blobmsg_add_u16(&mNetworkDiagnosticDataBuf, "DataVersion", diagTlv.mData.mLeaderData.mDataVersion);
+            blobmsg_add_u16(&mNetworkDiagnosticDataBuf, "StableDataVersion",
+                            diagTlv.mData.mLeaderData.mStableDataVersion);
+            blobmsg_add_u16(&mNetworkDiagnosticDataBuf, "LeaderRouterId", diagTlv.mData.mLeaderData.mLeaderRouterId);
+            blobmsg_close_table(&mNetworkDiagnosticDataBuf, jsonItem);
+            break;
+        }
+        case OT_NETWORK_DIAGNOSTIC_TLV_NETWORK_DATA:
+        {
+            char networkdata[OT_NETWORK_BASE_TLV_MAX_LENGTH + 1];
+            memset(networkdata, 0, sizeof(networkdata));
+            OutputBytes(diagTlv.mData.mNetworkData.m8, diagTlv.mData.mNetworkData.mCount, networkdata);
+            blobmsg_add_string(&mNetworkDiagnosticDataBuf, "NetworkData", networkdata);
+            break;
+        }
+        case OT_NETWORK_DIAGNOSTIC_TLV_IP6_ADDR_LIST:
+        {
+            jsonArray = blobmsg_open_array(&mNetworkDiagnosticDataBuf, "IP6AddressList");
+            for (uint16_t i = 0; i < diagTlv.mData.mIp6AddrList.mCount; ++i)
+            {
+                Ip6Address addr(diagTlv.mData.mIp6AddrList.mList[i].mFields.m8);
+                blobmsg_add_string(&mNetworkDiagnosticDataBuf, NULL, addr.ToString().c_str());
+            }
+            blobmsg_close_array(&mNetworkDiagnosticDataBuf, jsonArray);
+            break;
+        }
+        case OT_NETWORK_DIAGNOSTIC_TLV_MAC_COUNTERS:
+        {
+            jsonItem = blobmsg_open_table(&mNetworkDiagnosticDataBuf, "MACCounters");
+            blobmsg_add_u32(&mNetworkDiagnosticDataBuf, "IfInUnknownProtos",
+                            diagTlv.mData.mMacCounters.mIfInUnknownProtos);
+            blobmsg_add_u32(&mNetworkDiagnosticDataBuf, "IfInErrors", diagTlv.mData.mMacCounters.mIfInErrors);
+            blobmsg_add_u32(&mNetworkDiagnosticDataBuf, "IfOutErrors", diagTlv.mData.mMacCounters.mIfOutErrors);
+            blobmsg_add_u32(&mNetworkDiagnosticDataBuf, "IfInUcastPkts", diagTlv.mData.mMacCounters.mIfInUcastPkts);
+            blobmsg_add_u32(&mNetworkDiagnosticDataBuf, "IfInBroadcastPkts",
+                            diagTlv.mData.mMacCounters.mIfInBroadcastPkts);
+            blobmsg_add_u32(&mNetworkDiagnosticDataBuf, "IfInDiscards", diagTlv.mData.mMacCounters.mIfInDiscards);
+            blobmsg_add_u32(&mNetworkDiagnosticDataBuf, "IfOutUcastPkts", diagTlv.mData.mMacCounters.mIfOutUcastPkts);
+            blobmsg_add_u32(&mNetworkDiagnosticDataBuf, "IfOutBroadcastPkts",
+                            diagTlv.mData.mMacCounters.mIfOutBroadcastPkts);
+            blobmsg_add_u32(&mNetworkDiagnosticDataBuf, "IfOutDiscards", diagTlv.mData.mMacCounters.mIfOutDiscards);
+            blobmsg_close_table(&mNetworkDiagnosticDataBuf, jsonItem);
+            break;
+        }
+        case OT_NETWORK_DIAGNOSTIC_TLV_BATTERY_LEVEL:
+        {
+            blobmsg_add_u16(&mNetworkDiagnosticDataBuf, "BatteryLevel", diagTlv.mData.mBatteryLevel);
+            break;
+        }
+        case OT_NETWORK_DIAGNOSTIC_TLV_SUPPLY_VOLTAGE:
+        {
+            blobmsg_add_u16(&mNetworkDiagnosticDataBuf, "SupplyVoltage", diagTlv.mData.mSupplyVoltage);
+            break;
+        }
+        case OT_NETWORK_DIAGNOSTIC_TLV_CHILD_TABLE:
+        {
+            jsonArray = blobmsg_open_array(&mNetworkDiagnosticDataBuf, "ChildTable");
+            for (uint16_t i = 0; i < diagTlv.mData.mChildTable.mCount; ++i)
+            {
+                const otNetworkDiagChildEntry &entry = diagTlv.mData.mChildTable.mTable[i];
+
+                jsonItem = blobmsg_open_table(&mNetworkDiagnosticDataBuf, "child");
+                blobmsg_add_u16(&mNetworkDiagnosticDataBuf, "ChildId", entry.mChildId);
+                blobmsg_add_u16(&mNetworkDiagnosticDataBuf, "Timeout", entry.mTimeout);
+
+                void *t = nullptr;
+                t       = blobmsg_open_table(&mNetworkDiagnosticDataBuf, "Mode");
+                blobmsg_add_u32(&mNetworkDiagnosticDataBuf, "RxOnWhenIdle", entry.mMode.mRxOnWhenIdle);
+                blobmsg_add_u32(&mNetworkDiagnosticDataBuf, "DeviceType", entry.mMode.mDeviceType);
+                blobmsg_add_u32(&mNetworkDiagnosticDataBuf, "NetworkData", entry.mMode.mNetworkData);
+                blobmsg_close_table(&mNetworkDiagnosticDataBuf, t);
+
+                blobmsg_close_table(&mNetworkDiagnosticDataBuf, jsonItem);
+            }
+            blobmsg_close_array(&mNetworkDiagnosticDataBuf, jsonArray);
+            break;
+        }
+        case OT_NETWORK_DIAGNOSTIC_TLV_CHANNEL_PAGES:
+        {
+            char tChannelPage[OT_NETWORK_BASE_TLV_MAX_LENGTH + 1];
+            memset(tChannelPage, 0, sizeof(tChannelPage));
+            OutputBytes(diagTlv.mData.mChannelPages.m8, diagTlv.mData.mChannelPages.mCount, tChannelPage);
+            blobmsg_add_string(&mNetworkDiagnosticDataBuf, "ChannelPages", tChannelPage);
+            break;
+        }
+        case OT_NETWORK_DIAGNOSTIC_TLV_MAX_CHILD_TIMEOUT:
+        {
+            blobmsg_add_u32(&mNetworkDiagnosticDataBuf, "MaxChildTimeout", diagTlv.mData.mMaxChildTimeout);
+            break;
+        }
+
+        default:
+            // Ignore other network diagnostics data.
+            break;
+        }
+    }
+
+    blobmsg_close_table(&mNetworkDiagnosticDataBuf, sJsonUri);
+
+exit:
+    if (aError != OT_ERROR_NONE)
+    {
+        otbrLogWarning("Failed to receive diagnostic response: %s", otThreadErrorToString(aError));
+    }
+}
+
+int UbusServer::UbusSetInformation(struct ubus_context      *aContext,
+                                   struct ubus_object       *aObj,
                                    struct ubus_request_data *aRequest,
-                                   const char *              aMethod,
-                                   struct blob_attr *        aMsg,
-                                   const char *              aAction)
+                                   const char               *aMethod,
+                                   struct blob_attr         *aMsg,
+                                   const char               *aAction)
 {
     OT_UNUSED_VARIABLE(aObj);
     OT_UNUSED_VARIABLE(aMethod);
@@ -1457,6 +2439,7 @@ int UbusServer::UbusSetInformation(struc
             long  value;
             char *panid = blobmsg_get_string(tb[SETNETWORK]);
             SuccessOrExit(error = ParseLong(panid, value));
+            SuccessOrExit(error = (value > 65535) ? OT_ERROR_INVALID_ARGS : OT_ERROR_NONE);
             error = otLinkSetPanId(mController->GetInstance(), static_cast<otPanId>(value));
         }
     }
@@ -1468,7 +2451,7 @@ int UbusServer::UbusSetInformation(struc
         if (tb[SETNETWORK] != nullptr)
         {
             otNetworkKey key;
-            char *       networkkey = blobmsg_get_string(tb[SETNETWORK]);
+            char        *networkkey = blobmsg_get_string(tb[SETNETWORK]);
 
             VerifyOrExit(Hex2Bin(networkkey, key.m8, sizeof(key.m8)) == OT_NETWORK_KEY_SIZE, error = OT_ERROR_PARSE);
             SuccessOrExit(error = otThreadSetNetworkKey(mController->GetInstance(), &key));
@@ -1496,7 +2479,7 @@ int UbusServer::UbusSetInformation(struc
         if (tb[SETNETWORK] != nullptr)
         {
             otExtendedPanId extPanId;
-            char *          input = blobmsg_get_string(tb[SETNETWORK]);
+            char           *input = blobmsg_get_string(tb[SETNETWORK]);
             VerifyOrExit(Hex2Bin(input, extPanId.m8, sizeof(extPanId)) >= 0, error = OT_ERROR_PARSE);
             error = otThreadSetExtendedPanId(mController->GetInstance(), &extPanId);
         }
@@ -1592,6 +2575,69 @@ int UbusServer::UbusSetInformation(struc
     {
         otLinkFilterClearAddresses(mController->GetInstance());
     }
+    else if (!strcmp(aAction, "loglevel"))
+    {
+        struct blob_attr *tb[SET_NETWORK_MAX];
+        blobmsg_parse(setLogLevelPolicy, SET_NETWORK_MAX, tb, blob_data(aMsg), blob_len(aMsg));
+        if (tb[SETNETWORK] != nullptr)
+        {
+            uint8_t level = blobmsg_get_u32(tb[SETNETWORK]);
+            SuccessOrExit(error = otLoggingSetLevel(static_cast<otLogLevel>(level)));
+        }
+    }
+    else if (!strcmp(aAction, "setsrpsrvconfig"))
+    {
+        struct blob_attr *tb[SET_SRPSRVCONFIG_MAX];
+        blobmsg_parse(setSrpSrvConfigPolicy, SET_SRPSRVCONFIG_MAX, tb, blob_data(aMsg), blob_len(aMsg));
+
+        if ((tb[MINLEASE] != nullptr) && (tb[MAXLEASE] != nullptr) && (tb[KEYMINLEASE] != nullptr) &&
+            (tb[KEYMAXLEASE] != nullptr))
+        {
+            otSrpServerLeaseConfig leaseConfig;
+            leaseConfig.mMinLease    = blobmsg_get_u32(tb[MINLEASE]);
+            leaseConfig.mMaxLease    = blobmsg_get_u32(tb[MAXLEASE]);
+            leaseConfig.mMinKeyLease = blobmsg_get_u32(tb[KEYMINLEASE]);
+            leaseConfig.mMaxKeyLease = blobmsg_get_u32(tb[KEYMAXLEASE]);
+            SuccessOrExit(error = otSrpServerSetLeaseConfig(mController->GetInstance(), &leaseConfig));
+        }
+        if (tb[DOMAINNAME] != nullptr)
+        {
+            otSrpServerSetDomain(mController->GetInstance(), blobmsg_get_string(tb[DOMAINNAME]));
+        }
+        if (tb[SEQNUM] != nullptr)
+        {
+            SuccessOrExit(error = otSrpServerSetAnycastModeSequenceNumber(mController->GetInstance(),
+                                                                          blobmsg_get_u16(tb[SEQNUM])));
+        }
+        if (tb[ENABLE] != nullptr)
+        {
+            otSrpServerSetEnabled(mController->GetInstance(), blobmsg_get_bool(tb[ENABLE]));
+        }
+    }
+#if OTBR_ENABLE_BACKBONE_ROUTER
+    else if (!strcmp(aAction, "setbbrconfig"))
+    {
+        struct blob_attr *tb[SET_BBR_CONFIG_MAX];
+        blobmsg_parse(setBBRConfigPolicy, SET_BBR_CONFIG_MAX, tb, blob_data(aMsg), blob_len(aMsg));
+        if (tb[BBR_ENABLE] != nullptr)
+        {
+            otBackboneRouterSetEnabled(mController->GetInstance(), blobmsg_get_bool(tb[BBR_ENABLE]));
+        }
+        if ((tb[BBR_SEQNO] != nullptr) || (tb[BBR_DELAY] != nullptr) || (tb[BBR_TIMEOUT] != nullptr))
+        {
+            otBackboneRouterConfig config;
+            otBackboneRouterGetConfig(mController->GetInstance(), &config);
+            config.mSequenceNumber      = blobmsg_get_u32(tb[BBR_SEQNO]);
+            config.mReregistrationDelay = blobmsg_get_u32(tb[BBR_DELAY]);
+            config.mMlrTimeout          = blobmsg_get_u32(tb[BBR_TIMEOUT]);
+            SuccessOrExit(error = otBackboneRouterSetConfig(mController->GetInstance(), &config));
+        }
+        if (tb[BBR_JITTER] != nullptr)
+        {
+            otBackboneRouterSetRegistrationJitter(mController->GetInstance(), blobmsg_get_u32(tb[BBR_JITTER]));
+        }
+    }
+#endif
     else
     {
         perror("invalid argument in get information ubus\n");
@@ -1647,6 +2693,11 @@ void UbusServer::UbusReconnTimer(struct
     GetInstance().UbusReconnTimerDetail(aTimeout);
 }
 
+void UbusServer::UbusWatchdogTimer(struct uloop_timeout *aTimeout)
+{
+    GetInstance().UbusWatchdogTimerDetail(aTimeout);
+}
+
 void UbusServer::UbusReconnTimerDetail(struct uloop_timeout *aTimeout)
 {
     OT_UNUSED_VARIABLE(aTimeout);
@@ -1668,6 +2719,23 @@ void UbusServer::UbusReconnTimerDetail(s
     UbusAddFd();
 }
 
+void UbusServer::UbusWatchdogTimerDetail(struct uloop_timeout *aTimeout)
+{
+    OT_UNUSED_VARIABLE(aTimeout);
+
+    static struct uloop_timeout retry = {
+        list : {},
+        pending : false,
+        cb : UbusWatchdogTimer,
+        time : {},
+    };
+    int time = 30;
+
+    otbr::ubus::UbusServer::GetInstance().SendEvent(OT_EVENT_OTBR_WATCHDOG);
+
+    uloop_timeout_set(&retry, time * 1000);
+}
+
 void UbusServer::UbusConnectionLost(struct ubus_context *aContext)
 {
     OT_UNUSED_VARIABLE(aContext);
@@ -1724,6 +2792,13 @@ void UbusServer::InstallUbusObject(void)
         return;
     }
 
+    otSetStateChangedCallback(mController->GetInstance(), &UbusServer::HandleNetifStateChanged,
+                              mController->GetInstance());
+    otThreadRegisterNeighborTableCallback(mController->GetInstance(), &UbusServer::HandleNeighborTableChanged);
+    otbr::ubus::UbusServer::GetInstance().SendEvent(OT_EVENT_OTBR_INIT);
+
+    UbusWatchdogTimer(nullptr);
+
     otbrLogInfo("Uloop run");
     uloop_run();
 
@@ -1743,7 +2818,7 @@ int UbusServer::Hex2Bin(const char *aHex
 {
     size_t      hexLength = strlen(aHex);
     const char *hexEnd    = aHex + hexLength;
-    uint8_t *   cur       = aBin;
+    uint8_t    *cur       = aBin;
     uint8_t     numChars  = hexLength & 1;
     uint8_t     byte      = 0;
     int         rval;
@@ -1790,6 +2865,39 @@ exit:
     return rval;
 }
 
+void UbusServer::HandleNetifStateChanged(uint32_t aFlags, void *aContext)
+{
+    OT_UNUSED_VARIABLE(aFlags);
+    if ((aFlags & OT_CHANGED_THREAD_ROLE) != 0)
+    {
+        switch (otThreadGetDeviceRole(static_cast<otInstance *>(aContext)))
+        {
+        case OT_DEVICE_ROLE_DISABLED:
+            otbr::ubus::UbusServer::GetInstance().SendEvent(OT_EVENT_OTBR_DISABLED);
+            break;
+        case OT_DEVICE_ROLE_CHILD:
+        case OT_DEVICE_ROLE_ROUTER:
+        case OT_DEVICE_ROLE_LEADER:
+            otbr::ubus::UbusServer::GetInstance().SendEvent(OT_EVENT_OTBR_ENABLED);
+            break;
+        default:
+            break;
+        }
+    }
+}
+
+void UbusServer::HandleNeighborTableChanged(otNeighborTableEvent aEvent, const otNeighborTableEntryInfo *aEntry)
+{
+    GetInstance().HandleNeighborTableChanged(aEvent, *aEntry);
+}
+
+void UbusServer::HandleNeighborTableChanged(otNeighborTableEvent aEvent, const otNeighborTableEntryInfo &aEntry)
+{
+    OT_UNUSED_VARIABLE(aEvent);
+    OT_UNUSED_VARIABLE(aEntry);
+    otbr::ubus::UbusServer::GetInstance().SendEvent(OT_EVENT_OTBR_NEIGHBOR_TABLE_CHANGED);
+}
+
 void UBusAgent::Init(void)
 {
     otbr::ubus::sUbusEfd = eventfd(0, 0);
Index: ot-br-posix-2022-11-08-r3/src/openwrt/ubus/otubus.hpp
===================================================================
--- ot-br-posix-2022-11-08-r3.orig/src/openwrt/ubus/otubus.hpp
+++ ot-br-posix-2022-11-08-r3/src/openwrt/ubus/otubus.hpp
@@ -42,6 +42,7 @@
 #include <openthread/ip6.h>
 #include <openthread/link.h>
 #include <openthread/netdiag.h>
+#include <openthread/thread_ftd.h>
 #include <openthread/udp.h>
 
 #include "common/code_utils.hpp"
@@ -768,12 +769,105 @@ public:
      */
     void HandleDiagnosticGetResponse(otError aError, otMessage *aMessage, const otMessageInfo *aMessageInfo);
 
+    /**
+     * Ubus Extend Interface
+     */
+    void SendEvent(int aEvent);
+    static void ExtHandleDiagnosticGetResponse(otError              aError,
+                                               otMessage *          aMessage,
+                                               const otMessageInfo *aMessageInfo,
+                                               void *               aContext);
+    void        ExtHandleDiagnosticGetResponse(otError aError, otMessage *aMessage, const otMessageInfo *aMessageInfo);
+
+    static int UbusExtGetThreadStatus(struct ubus_context *     aContext,
+                                      struct ubus_object *      aObj,
+                                      struct ubus_request_data *aRequest,
+                                      const char *              aMethod,
+                                      struct blob_attr *        aMsg);
+    static int UbusExtGetThreadGraph(struct ubus_context *     aContext,
+                                     struct ubus_object *      aObj,
+                                     struct ubus_request_data *aRequest,
+                                     const char *              aMethod,
+                                     struct blob_attr *        aMsg);
+    static int UbusExtGetTxPower(struct ubus_context *     aContext,
+                                 struct ubus_object *      aObj,
+                                 struct ubus_request_data *aRequest,
+                                 const char *              aMethod,
+                                 struct blob_attr *        aMsg);
+    static int UbusExtJoinerState(struct ubus_context *     aContext,
+                                  struct ubus_object *      aObj,
+                                  struct ubus_request_data *aRequest,
+                                  const char *              aMethod,
+                                  struct blob_attr *        aMsg);
+    static int UbusExtCommissionerStopHandler(struct ubus_context *     aContext,
+                                  struct ubus_object *      aObj,
+                                  struct ubus_request_data *aRequest,
+                                  const char *              aMethod,
+                                  struct blob_attr *        aMsg);
+    static int UbusExtCommissionerStateHandler(struct ubus_context *     aContext,
+                                  struct ubus_object *      aObj,
+                                  struct ubus_request_data *aRequest,
+                                  const char *              aMethod,
+                                  struct blob_attr *        aMsg);
+#if OTBR_ENABLE_BACKBONE_ROUTER
+    static int UbusGetBBRStatus(struct ubus_context *     aContext,
+                                  struct ubus_object *      aObj,
+                                  struct ubus_request_data *aRequest,
+                                  const char *              aMethod,
+                                  struct blob_attr *        aMsg);
+    static int UbusSetBBRConfigHandler(struct ubus_context *     aContext,
+                                  struct ubus_object *      aObj,
+                                  struct ubus_request_data *aRequest,
+                                  const char *              aMethod,
+                                  struct blob_attr *        aMsg);
+#endif
+    static int UbusSetLogLevelHandler(struct ubus_context *     aContext,
+                                  struct ubus_object *      aObj,
+                                  struct ubus_request_data *aRequest,
+                                  const char *              aMethod,
+                                  struct blob_attr *        aMsg);
+    static int UbusGetSrpServerConfigHandler(struct ubus_context *     aContext,
+                                  struct ubus_object *      aObj,
+                                  struct ubus_request_data *aRequest,
+                                  const char *              aMethod,
+                                  struct blob_attr *        aMsg);
+    static int UbusGetSrpServerServiceHandler(struct ubus_context *     aContext,
+                                  struct ubus_object *      aObj,
+                                  struct ubus_request_data *aRequest,
+                                  const char *              aMethod,
+                                  struct blob_attr *        aMsg);
+    static int UbusSetSrpServerConfigHandler(struct ubus_context *     aContext,
+                                  struct ubus_object *      aObj,
+                                  struct ubus_request_data *aRequest,
+                                  const char *              aMethod,
+                                  struct blob_attr *        aMsg);
+    static int UbusGetLocalAddrHandler(struct ubus_context *     aContext,
+                                  struct ubus_object *      aObj,
+                                  struct ubus_request_data *aRequest,
+                                  const char *              aMethod,
+                                  struct blob_attr *        aMsg);
+    static int UbusGetActiveTimestampHandler(struct ubus_context *     aContext,
+                                  struct ubus_object *      aObj,
+                                  struct ubus_request_data *aRequest,
+                                  const char *              aMethod,
+                                  struct blob_attr *        aMsg);
+    static int UbusGetBufferInfoHandler(struct ubus_context *     aContext,
+                                  struct ubus_object *      aObj,
+                                  struct ubus_request_data *aRequest,
+                                  const char *              aMethod,
+                                  struct blob_attr *        aMsg);
+    static int UbusGetServicesInfoHandler(struct ubus_context *     aContext,
+                                  struct ubus_object *      aObj,
+                                  struct ubus_request_data *aRequest,
+                                  const char *              aMethod,
+                                  struct blob_attr *        aMsg);
 private:
     bool                       mIfFinishScan;
     struct ubus_context *      mContext;
     const char *               mSockPath;
     struct blob_buf            mBuf;
     struct blob_buf            mNetworkdataBuf;
+    struct blob_buf            mNetworkDiagnosticDataBuf;
     Ncp::ControllerOpenThread *mController;
     std::mutex *               mNcpThreadMutex;
     time_t                     mSecond;
@@ -1048,6 +1142,7 @@ private:
      *
      */
     static void UbusReconnTimer(struct uloop_timeout *aTimeout);
+    static void UbusWatchdogTimer(struct uloop_timeout *aTimeout);
 
     /**
      * This method detailly handle ubus reconnect time.
@@ -1056,6 +1151,7 @@ private:
      *
      */
     void UbusReconnTimerDetail(struct uloop_timeout *aTimeout);
+    void UbusWatchdogTimerDetail(struct uloop_timeout *aTimeout);
 
     /**
      * This method handle ubus connection lost.
@@ -1123,6 +1219,10 @@ private:
      *
      */
     void AppendResult(otError aError, struct ubus_context *aContext, struct ubus_request_data *aRequest);
+
+    static void HandleNetifStateChanged(uint32_t aFlags, void *aContext);
+    static void HandleNeighborTableChanged(otNeighborTableEvent aEvent, const otNeighborTableEntryInfo *aEntry);
+    void        HandleNeighborTableChanged(otNeighborTableEvent aEvent, const otNeighborTableEntryInfo &aEntry);
 };
 
 class UBusAgent : public MainloopProcessor
